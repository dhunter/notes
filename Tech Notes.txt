- Data Science
	- Resources
		- BeautifulSoup, (web scraping) Video - https://www.youtube.com/watch?v=ng2o98k983k
		- IBM Data Science Professional Certificate - https://www.coursera.org/professional-certificates/ibm-data-science#courses
		- labs.cognitiveclass.ai
		- Seaborn - Python visualization library
	- Data Science Methodology
		- Business Understanding, (↓)
			- Form a concrete business or research problem
				- Questions / concerns are best addressed during this stage
		- Analytic Approach, (↓)
			- Which approach(es) will be most effective to answer the question(s) in the Business Understanding stage?
		- Data Requirements, (↑↓)
			- What data do you need to answer the question(s)?
		- Data Collection, (↑↓)
			- Where is data coming from, (identify all sources)
			- How will you get it?
		- Data Understanding, (↓)
			- Checking overall data quality
			- Descriptive Statistics
			- Univariate Modeling
			- Pairwise Correlation
				- Correlating pairs of variables to look for ones that are highly correlated and thus redundant / skewing
			- Histogram Generation
		- Data Preparation, (↑↓,→ to Data Collection)
			- 70-90% of total project time
				- Automation of data conversion highly valuable.
			- Consideration of what to do with missing / invalid data
			- Feature Engineering
				- Using domain knowledge, etc to create features from variables
		- Modeling, (↑↓)
			- Descriptive vs Predictive
			- For Predictive only, use Training and Test sets, (commonly 70% / 30% of available data, respectively)
		- Evaluation, (↓)
			- Did the model answer the question answered?
			- Prescriptive - Use Decision Tree to validate
			- Descriptive - Test model output vs another dataset where outcome is known.
			- Statistical Significance
			- ROC Curve
				- Diagnostic tool for classification model evaluation
				- True-Positive Rate vs False-Positive Rate
					- Optimal model at maximum separation between two curves.
		- Deployment, (↓)
		- Feedback, (↓, → to Modeling)
			- Define review process
				- Period of time for initial review
				- Measure results of applying model
					- Test vs Control groups, (if ethical)
					- Before vs After implementation, (if using Control group unethical)
			- Determine potential model refinements
				- If cost-effective, backtest impact of refinements vs. data from review process
					- To determine potential impact
				- Implement, if desired.
	- Databases and SQL for Data Science
		- In Jupyter notebooks
			- "%sql" says the rest of the statement is sql
			- "%%sql" says the rest of the block is sql
		- In Python
			- To avoid EOL errors in strings, make sure to use triple quotes, (including all sql statements)
	- Data Analysis with Python, (with pandas, numpy, etc)
		- Data Preprocessing
			- Finding missing values
				- <code_block>
					missing_data = dataframe.isnull()
					for column_name in missing_data.columns.values.tolist()
						print(column_name)
						print(missing_data[column_name].value_counts())
						print("")
				- </code_block>
			- Replacing missing values
				- dataframe.fillna(value_you_want_to_fill_with)
				- Categorical features
					- Can replace by mode of column / feature
						- Effectively the non-numeric version of averaging the column, with all the plusses and minuses thereof
						- <code_block>
							feature_mode = dataframe[column_name].value_counts().idxmax()
							dataframe[column_name].replace(numpy.nan, feature_mode, inplace = True)					
						- </code_block>
			- Dropping values
				- dataframe.dropna(axis, inplace)
					- axis = 0 drops the row, = 1 drops the column
					- inplace = True modifies the dataframe itself, = False does not.
			- Data Formatting
				- Converting mpg to metric equivalent, (L/100km)
					- dataframe['mpg'] = 235/dataframe['mpg']
				- Converting erroneous column data type
					- (i.e. changing column from an object to an int/float)
					- dataframe[column_name] = dataframe[column_name].astype(type)
			- Data Normalization
				- To ensure variables with larger scales won't have a larger impact than ones with smaller scales during regression
				- Simple Feature Scaling - current / max - 0-1 scale
				- Max-min - (current-min)/(max-min) - 0-1 scale
				- Z-score - (current-mean)/std dev - ~-3-3 scale
			- Binning
				- Converting numeric feature into new categorical feature
					- <code_block>
						bins = numpy.linspace(min(dataframe[column_name]),max(dataframe[column_name]),number_of_bins)
						bin_names = [list_of_bin_names]
						dataframe[new_binned_column_name] = pandas.cut(dataframe[column_name],bins,labels=bin_names,include_lowest = True)
					- </code_block>
			- One-hot encoding, (i.e. creating dummy variables)
				- Converting a single categorical feature into multiple 0/1 numeric features
					- pandas.get_dummies(dataframe[column_name])
		- Exploratory Data Analysis
			- Descriptive Statistics
				- dataframe.describe()
					- Warning - All NaN values will be excluded
						- So will not serve as a double-check that you've completed pre-processing properly
							- On the upside, also means that pre-processing isn't required to use.
			- Categorical summarization
				- <code_block>
					# Entire dataframe - number of unique category values, top category value, frequency of top category value
					dataframe.describe(include=['object'])

					# Counts of all category values within a categorical variable
					dataframe[column_name].value_counts()
				- </code_block>
			- Grouping into subcategories, (example uses mean - could be any stat)
				- <code_block>
					dataframe_temp = dataframe[[independent_column_1,independent_column_2,dependent_column]]

					# Provides mean of dependent_column for each independent_column_2 within each independent_column_1
					dataframe_grouped = dataframe_temp.groupby([independent_column_1,independent_column_2], as_index = False).mean()

					# (Optional) - Convert to pivot table
					dataframe_pivot = dataframe_grouped.pivot(index = independent_column_1, columns = independent_column_2)

					# (Optional after pivot) - Convert to Heatmap
					matplotlib.pyplot.pcolor(dataframe_pivot, cmap = desired_color_scheme)
					matplotlib.pyplot.colorbar()
					matplotlib.pyplot.show()
				- </code_block>
			- Correlation
				- Visualizations
					- Steep slopes, negative or positive, indicate strong correlation
					- Flat slopes indicate weak correlation
					- <code_block>
						# Scatterplot with linear regression line
						seaborn.regplot(x = independent_column, y = dependent_column, data = dataframe)

						# Force y to start at 0
						matplotlib.pyplot.ylim(0,		
					- </code_block>
				- Pearson Correlation
					- Measures strength of correlation
					- Correlation Coefficient
						- How strong is the actual correlation?
						- Close to +1 - Large positive correlation
						- Close to -1 - Large negative correlation
						- Close to 0 - No relationship
					- P-value
						- How confident are we that that correlation exists?
						- P < 0.001 - Strong certainty of the correlation
						- P < 0.05 - Moderate certainty
						- P < 0.1 - Weak certainty
						- P > 0.1 - No certainty
					- <code_block>
						# For just the coefficient and p-value between two variables
						pearson_coefficient, p_value = scipy.stats.pearsonr(dataframe[column_1], dataframe[column_2])
		
						# For correlation table of just coefficients, (i.e. no p-values)
						dataframe.corr()  # For the entire dataframe
						dataframe[[column_1,column_2,...,column_n]].corr() # For only examining correlations for specific variables.
					- </code_block>
				- Analysis of Variance, (ANOVA)
					- Used to find variation between individual categories for categorical variables
						- i.e. average price of a car by make, (i.e. Toyota, Saab, etc)
					- F-test score
						- Variation between each (categorical group mean / intra-category variation)
							- i.e. (Subaru ave price / difference in Subaru prices per observation) vs (Honda ave price / difference in Honda prices per observation)
						- Will be higher the higher variation exists.
							- i.e. will be small for Subaru vs Honda / Toyota
								- Will be large for Subaru vs Jaguar / Mercedes / Porsche
					- P-value
						- (as in Pearson Correlation)
					- <code_block>
						dataframe_anova = dataframe[[independent_categorical_column, dependent_column]]  # dataframe[['make', 'price']]
						grouped_anova = dataframe_anova.groupby([independent_categorical_column])  # .groupy(['make'])
						anova_results_1 = scipy.stats.f_oneway(grouped_anova.get_group(category_value_1)[dependent_column], grouped_anova.get_group(category_value_2)[dependent_column])  # .get_group('honda')['price']   .get_group('subaru')['price']
					- </code_block>
		- Model Development
			- Regression
				- Linear
					- <code_block>
						linear_regression_model = sklearn.linear_model.LinearRegression()
						x = dataframe[[independent_variable(s)]]
						y = dataframe[dependent_variable]
						linear_regression_model.fit(x, y)

						# Obtain predictions
						y_hat = linear_regression_model.predict(x)  # Using stats convention of a carat or "hat" over a letter to indicate that that value is a prediction, not an actual value.

						# Obtain y-intercept & slope
						linear_regression_model.intercept_
						linear_regression_model.coef_ # Returns an array, even if only one independent variable is used.
					- </code_block>
					- Visualizations
						- Regression Plot
							- (as in the Correlation section - "Scatterplot with linear regression line")
						- Residual Plot
							- If linear regression proper as a model type for the given independent_variable, expect residuals to:
								- Have a mean = 0
								- Be randomly spread out above and below the mean, regardless of independent_variable value
									- i.e. The spread should look the same at x = 0 and x = (infinity)
								- Have no curvature
							- seaborn.residplot(dataframe[independent_variable],[dependent_variable])
						- Distribution Plot
							- y, (actual) vs y_hat, (predicted)
								- Helps to show regions of independent_variable where the model may not be a good predictor						- <code_block>
							- <code_block>
								ax1 = seaborn.distplot(dataframe[dependent_variable], hist = False, color = desired_color, label = "Actual Value")
								seaborn.displot(y_hat, hist = False, color = another_desired_color, label = "Fitted Values", ax = ax1)
							- </code_block>
				- Polynomial
					- For independent variables where the presumption that the relationship between that independent_variable and dependent_variable is linear is false
						- (i.e. where the Residual Plot, above, doesn't conform to the 3 expectations)
					- Can be either one-dimensional
						- Will only have a single independent_variable squared, cubed, etc
							- i.e. y_hat = Intercept + A(x1) + B(x1)^2 + C(x1)^3 + ...
						- <code_block>
							one_dimensional_whatever_order = numpy.polyfit(x, y, whatever_order_youre_trying_to_test) # i.e. squared, cubed, ^4, etc
							whatever_order_polynomial = numpy.poly1d(one_dimensional_whatever_order)
							print(whatever_order_polynomial)
						- </code_block>
					- Or multi-dimensional
						- Where multiple independent variables will be varied concurrently
							- i.e. y_hat = Intercept + A(x1) + B(x2) + C(x1)(x2) + D(x1)^2 + E(x2)^2 + ...
						- <code_block>
							# Scikit-learn can't do multi-dimensional directly, so have to do some preprocessing first

							# If not using pre-scaled variables, scale each independent variable before combining
							# scaled_variables = sklearn.preprocessing.StandardScaler
							# scaled_variables.fit(dataframe[[independent_variable_1,independent_variable2]])  # ,...
							# multiple_independent_variables = scaled_variables.transform(dataframe[[independent_variable_1,independent_variable2]])  #,...

							# If using pre-scaled variables
							multiple_independent_variables = dataframe[[independent_variable_1, independent_variable_2]]

							multi_dimensional_whatever_order = sklearn.preprocessing.PolynomialFeatures(degree = whatever_order_youre_trying_to_test, include_bias = False)
							combined_multiple_independent_variables = sklearn.preprocessing.PolynomialFeatures.fit_transform(multiple_independent_variables)  # TODO: at 2019-03-28, not entirely positive that this use of fit_transform fits quite right after the scaling section, so should test and modify, as appropriate.
						- </code_block>
					- <code_block>
						# Alternative Method, Using Pipelines
						## Performing the entire scaling -> polynomial transformation -> regression at once
						input = [('scale',sklearn.preprocessing.StandardScaler()),
							('polynomial',sklearn.preprocessing.PolynomialFeatures(degree=whatever_order_youre_trying_to_test),
							('model',sklearn.linear_model.LinearRegression())]
						pipe = sklearn.pipeline.Pipeline(input)
						pipe.train(dataframe[[independent_variable_1,independent_variable_2]], dependent_variable)   # ,... for more independent variables.
						y_hat = pipe.predict(dataframe[[independent_variable_1,independent_variable_2]])
					- </code_block>
				- Evaluating Accuracy
					- Mean Squared Error, (MSE)
						- Sum of Squared Errors, (SSE) / # of samples
						- sklearn.metrics.mean_squared_error(dataframe[dependent_variable], y_hat)
					- R^2, (Coefficient of Determination)
						- How close the data is fitted to the regression line
							- i.e. % of variation in dependent_variable explained by the model
						- 1 - (MSE of regression line) / (MSE of actual data)  

						- sklearn.linear_model.LinearRegression.score(dataframe[independent_variable],dataframe[dependent_variable])
					- Training, (in-sample) vs Testing, (out-of-sample) sets
						- (often 70/30)
						- x_train, x_test, y_train, y_test = sklearn.model_selection.train_test_split([independent_variables_1-n],[dependent_variable],test_size = decimal_of_percent_of_data_you_want_as_test_set_ie_0.3_for_a_70_30_split, random_state = 0)
							- Can and should run multiple times to train and test the model on different groups of training and testing data
						- Cross Validation
							- Separate data into N groups, ("folds")
							- Run training and testing using different groups for training and testing
								- Until all groups have been used both to train and to test
							- Use ave of out-of-sample error, (i.e. R^2) for all of these iterations as final out-of-sample error
							- sklearn.model_selection.cross_val_score(initialized_object_for_type_of_model_used,[independent_variables_1-n],[dependent_variable],cv = number_of_folds_used)
								- Returns an array of R^2 values for each fold iteration
							- sklearn.model_selection.cross_val_predict(initialized_object_for_type_of_model_used,[independent_variables_1-n],[dependent_variable],cv = number_of_folds_used)
								- Returns an array of predicted values for the test set of each fold iteration
					- Underfitting vs Overfitting
						- (for polynomial regression)
						- Underfitting
							- Model not complex enough, (i.e. doesn't use a high enough order function) to well describe the true model, (i.e. using a linear model to describe a parabolic true function)
						- Overfitting
							- Model so complex that it better tracks the training data than the actual true function
								- Which is a problem since the training data combines elements of the true function / predictable variation, (which we want) and elements of noise / non-predictable variation, (which we don't)
							- Example:
								- Given - the model that's the closest estimator, (i.e. lowest MSE/R^2 of the test data) is an 8th order function
								- A second model is run that's a 16th order function
								- The 16th order function has a lower error vs the training points vs the 8th order function
									- But now a higher error vs the true function, (/ test points).
						- If you graph function order on x axis, MSE of test data on y axis
							- Should select min(MSE) function order
								- Any orders to the left of that are underfit
								- Any orders to the right are overfit
						- Can also look for max(R^2) vs function order for any given independent variable
							- <code_block>
								r_squared_test = []
								order = [1,2,3,4]  # to whatever order max you'd like
								
								for n in order:
									polynomial_regression = sklearn.preprocessing.PolynomialFeatures(degree = n)								
									x_train_polynomial_regression = polynomial_regression.fit_transform(x_train[[independent_variable]])
									x_test_polynomial_regression = polynomial_regression.fit_transform(x_test[[independent_variable]])

									linear_regression = sklearn.linear_model.LinearRegression()
									linear_regression.fit(x_train_polynomial_regression, y_train)

									r_squared_test.append(linear_regression.score(x_test_polynomial_regression,y_test)
							- </code_block> 
						- Ridge Regression
							- Tries to smooth / reduce effect of outliers on regression line
								- i.e. forces the model to underfit to varying, selected, degrees
									- By modifying model-derived coefficients by a selectable "hyperparameter," (i.e. not included in fitting or training processes) alpha
										- Higher alpha goes, higher the underfitting
											- Select alpha that maximizes R^2, minimizes MSE, etc)
							- <code_block>
								ridge_model = sklearn.linear_model.Ridge(alpha = whatever_value_you_want)
								ridge_model.fit(x, y)
								y_hat = ridge_model.predict(x)
							- </code_block>
							- Grid Search
								- Automated process of picking best hyperparameters, (in this case, alpha)
								- Breaks data into 3 sets
									- Training, (regular usage)
									- Validation, (to determine best values of hyperparameters to min MSE / max R^2)
									- Test, (regular usage)
								- <code_block>
									hyperparameters = [{'alpha':[1, 10, 100, 1000], 'normalize':[True, False]}]   # For 'alpha' - or whatever other values of alpha you want to test.  'normalize' is whether the model will auto-normalize the independent variables before testing
									ridge_regression = sklearn.linear_model.Ridge()

									grid_search = sklearn.model_selection.GridSearchCV(ridge_regression, hyperparameters, cv = number_of_folds_you_want_to_use)

									grid_search.fit(x_data[[independent_variables]],y_data)  # By default, uses R^2
									grid_search.best_estimator_

									scores = grid_search.cv_results_
									scores['mean_test_score']  # Returns an array of the variant R^2's on test data

									# (Optional) If you want to print out all of the permutations of hyperparameters with their scores
									# for param, mean_train, mean_test inzip(scores['params'], scores['mean_train_score'], scores['mean_test_score']):
									# 	print(param, "R^2 on test data:", mean_test, "R^2 on train data:", mean_train)
								- </code_block>
	- Data Visualization with Python
		- Box Plots
			- Max and Min do not include outliers
				- In order to be considered an outlier, value must be < Q1 or > Q3 by at least 1.5 * the Interquartile Range, (IQR)
					- IQR = Q3 - Q1
	- Machine Learning with Python
		- Accuracy
			- Training
				- Accuracy of predictions to the training set
				- High levels can be a bad thing, as could show over-fitting
					- If training is using the entire dataset
						- (vs. train/test split)
			- Out-of-sample
				- Accuracy of predictions to data not in the training set
				- This is what we're trying to optimize
			- For classifier models, (i.e. labeled/non-continuous dependent variables)
				- Jaccard Index, (best = 1.0)
					- Intersection of predicted vs actual / Union of predicted vs actual
				- F1 Score, (best = 1.0)
					- Use Confusion Matrix, (y axis = true labels, x axis = predicted lables)
						- Hones in on odds of:
							- True Positive & Negative, (predicted = actual)
							- False Positive & Negative, (predicted =/= actual)
						- Calculate Precision & Recall for each class
							- Precision = True Positive / (True Positive + False Positive)
							- Recall = True Positive / (True Positive + False Negative)
						- F1 Score(each class) = 2 * (Precision * Recall) / (Precision + Recall)
						- F1 Score(classifier model) = Non-weighted average(F1 Score(each class) for all classes)
				- Log Loss, (best = 0)
					- Where the predicted output is a probability value between 0 and 1
					- Calculates how far the prediction is from the actual
						- So want to minimize this value
					- Non-weighted average of (actual * log(predicted)) + ((1 - actual) * log(1 - predicted)) for each row
		- Linear vs Non-Linear Relationships
			- Alternative to scatter plots
				- Run correlation matrix
					- If correlation >= 0.7, relationship is linear
		- K-Nearest Neighbors
			- Selecting K
				- Train/test split, train model with multiple K's, select K with highest accuracy
			- If using for continuous dependent variables, (i.e. regression targets)
				- Use median of K-nearest neighbors
		- Decision Trees
			- Select attribute order by which attribute does the best job of differentiation
				- (Best differentiation = most "pure" = lowest "entropy" / homogeneity of split data)
				- Best job = which attribute has the greatest "Information Gain"
					- Information Gain = (Entropy before split) - (weighted Entropy after split)
						- Entropy = - p(A) * log( p(A) ) - p(B) * log ( p(B) )
							- Entropy = 0 if split data perfectly homogeneous, (i.e. 0 of type A, 8 of type B)
							- Entropy = 1 if split data perfectly heterogeneous, (i.e. 4 of type A, 4 of type B)
							- So always looking to minimize this value.
		- Logistic Regression
			- Regression for categorical dependent variables
		- Support Vector Machine, (SVM)
			- Supervised algorithm that classifies cases by finding separators for non-linearly-separable data
				- Maps data to high-dimensional feature space
					- By converting data until it -is- linearly separable, (kernelling)
						- (i.e. x -> x^2, etc)
				- Then estimates hyper-plane separator
					- Best separator is the one with the largest "margin" possible
						- (Margin = distance between the differentiated regions)
						- (Data points closest to opposing group are called "support vectors," and are what are used to maximize margin)
			- Good for:
				- Image recognition
				- Text category assignment
				- Spam detection
				- Sentiment analysis
				- Gene expression classification
			- Cons
				- Prone to over-fitting
				- Will not provide probabilities of a point existing in either group
				- Too computationally expensive for large data sets
					- (Becomes problematic over ~1000 rows) 
		- Clustering
			- K-Means
				- Centroids (generally) initially chosen randomly
					- (could also pick a random data points and assign as centroids)
				- Assign each data point to centroid with minimum distance
				- Move centroids to means of clusters and re-assign data points
					- Continue until cluster movement below a threshold
				- Note: Final results strongly dependent on initial centroids
					- So need to run multiple times with different centroids each time
				- Selecting k
					- Run with multiple k's
					- Compare each k to MSE of clusters
					- Select k where reduction in MSE significantly reduces, (i.e. "elbow point")
						- Since MSE will always reduce with an increase in k
				- Pros
					- Much more efficient for large datasets
				- Cons
					- Has no concept of outliers / all data points are assigned to a cluster
						- So no way to determine anomalies
			- Hierarchical Clustering
				- Divisive, (top-down)
					- Start with one cluster, then move into each cluster and cluster within.
						- To whatever level desired
				- Agglomerative, (bottom-up)
					- More popular approach
					- Each data point starts as its own cluster
						- Clusters are merged by closest distance, reducing number of clusters
						- Distances recomputed with single values for new merged clusters
							- Options for values to use for merged clusters
								- Single-Linkage Clustering
									- Distance between nearest data points in each cluster
								- Complete-Linkage Clustering
									- Distance between farthest data points in each cluster
								- Average Linkage Clustering
									- Mean of distances of every point in one cluster to every point in another
								- Centroid Linkage Clustering
									- Using cluster centroid / mean
						- Repeat until either:
							- All clusters are merged
							- Cluster similarity minimum is exceeded
								- (i.e. you specifically decide that you will only merge clusters where the distance between them is below a selected value)
				- Pros
					- Does not require number of clusters to be specified
					- Provides ability to drill-down from clusters to sub-clusters
					- Always generates the same clusters
			- Density-Based Clustering, (DBSCAN)
				- (_D_ensity-_B_ased _S_patial _C_lustering of _A_pplications with _N_oise)
				- For use with arbitrarily-shaped clusters or clusters inside other clusters
					- (for the latter, think of Cluster A as being a donut, with Cluster B being inside the whole, where there is no hierarchical relationship between them)
				- Locates regions of high density separated by regions of low density
					- Using
						- R, (radius of neighborhood)
						- M, (min number of neighbors required to declare a cluster)
					- Differentiates points into:
						- Core
							- Within radius R, there are a min of M points, (inclusive of given point)
						- Border
							- Within radius R of a core point, but with M < min within R of given point
						- Outlier
							- Neither a core nor border point
								- i.e. not a core point, nor within radius R of a core point
					- And then creates clusters of all core and associated border points where:
						- A given core point is within radius R of another core point
				- Pros
					- Identifies outliers / does not assign every data point to a cluster
					- Does not require number of clusters to be specified
- Web Design
	- Resources
		- The Complete [current year] Web Development Bootcamp - https://www.udemy.com/course/the-complete-web-development-bootcamp/learn/lecture/17039626?start=0#content
		- The Coding Interview Bootcamp: Algorithms + Data Structures - https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/learn/lecture/8534250?start=0#content
	- CSS elements with multiple measurements on one line
		- The numbers start on the top and go clockwise around the item	
		- {border: 0px 10px 20px 30px;} would have a:
			- 0px border on top
				- (0 doesn't require a measurement type, but can still use)
			- 10px border on the right side
			- 20px border on the bottom
			- 30px border on the left side
		- Shorthand options
			- {border: 0px 10px 20px;}
				- 0px on top
				- 10px on left and right
				- 20px on bottom
			- {border: 0px 10px;}
				- 0px border on top and bottom
				- 10px border on left and right
			- {border: 0px;}
				- 0px border on all four sides
	- Displaying Elements
		- display: block --> nothing else on the same line, but can set width/height
		- display: inline --> anything can appear on same line, but can't set width/height
		- display: inline-block --> combination of prior two
			- Can appear on same line and also can set width/height
		- Hiding Elements
			- (for quizzes, etc)
			- display: none --> removes both the element and its position in the document
				- As if you just deleted the element entirely in the page source
			- visibility: hidden --> removes the element, but keeps its position
				- i.e. you'll see a hole where the element should have been displayed
	- Positioning
		- float: [left/right/etc]
			- Text that was below will now surround the targeted tag
		- position: static - (default) - positioned according to the normal flow of document
		- position: relative
			- Setting top, right, bottom or left properties will move the item relative to its normal, (position: static) position
		- position: fixed
			- Holds position relative to viewport
			- Does not move with scrolling
			- (Can use for menu bar, etc)
		- position: absolute
			- Setting top, right, bottom or left properties will move the item relative to its parent element's position, (including <body>, if no other parents)
			- Moves with scrolling.
		- position: sticky
			- position: relative until it's original position is reached in the document, then swaps to position: fixed
			- (A somewhat more elegant menu bar, etc, if {top: 0;})
		- z-index
			- Only works on items where all items in question have position <> static
				- (Items to go behind need position: absolute/fixed/sticky)
			- Determines 3D display order, (default: 0)
			- Lower values appear behind higher ones
				- If z-indexes are equal, items coming first in the html code will be displayed behind items that come after
					- i.e. if you have 3 divs with equal z-indexes, listed one after another in an html file:
						- Div 1 will be displayed at the back
						- Div 2 will be displayed in the middle
						- Div 3 will be displayed in the front
		- Keeping footer at the bottom of the page without always being displayed
			- In css file
				- html {
					  min-height: 100%;
					  position: relative;
				  }

				  body {
					  margin-bottom: [height of footer];
				  }

				  [footer class/id/however else you access it] {
					  bottom: 0;
					  height: [height of footer];
					  position: absolute;
					  width: 100%
				  }
	- Fonts
		- Embedding
			- In header:
				- <link href="https://fonts.googleapis.com/css?=family[name of family1]|[name of family2]|[name of family3]" rel="stylesheet">
		- Sizing
			- 16px, (fixed size) = 100%, (scaling) = 1em, (scaling) = 1rem, (scaling)
				- To convert fixed font size to scaling, divide by 16 = Xem/Xrem
			- Note: scaling inherits from all parent elements
				- So, if <body> is 2em and <h1> is 3em, final size = 6em
				- Unless you use "rem," which ignores all parent settings
					- So, in above, if <h1> is 3rem, (instead of 3em), final size = 3em
	- Designer vs Non-Designer Thinking
		- https://www.udemy.com/course/the-complete-web-development-bootcamp/learn/lecture/12399734#content
		- Color Theory
			- Different shades have different "moods"
				- i.e. Elicit different reactions in people seeing them
					- Many of those reactions are common
				- Good exercise is to analyze (especially print) ads to see how they use color to evoke desired reactions
			- Red
				- Love, Energy, Intensity
				- Generates excitement
			- Yellow
				- Joy, Intellect, Attention
				- Too much yellow can generate attention fatigue
			- Green
				- Freshness, Safety, Growth
				- (Often used for food ads)
			- Blue
				- Stability, Trust, Serenity
				- (medical/medicine/health)
			- Purple
				- Royalty, Wealth, Femininity
			- Combining Colors to make Color Palettes
				- Analogous Colors, (2 colors)
					- Selecting adjacent colors on the color wheel
					- Harmonious, Easy to look at for long periods.
					- Good for primary interface
				- Complimentary Colors, (2 colors)
					- Selecting diametrically-opposed colors on the color wheel
					- Attention-grabbing, but hard to look at for long periods.
					- Bad choice for primary interface.
				- Split Colors, (3 colors)
					- Way of toning down disharmony of Complimentary
					- Instead of picking complimentary color, instead the pick two colors surrounding the complimentary color.
					- Still attention-grabbing, but not as clashy
				- Triadic Colors, (3 colors)
					- Selecting 3 colors equidistant around color wheel
				- Monochromatic, (2 colors)
					- Adding darker or lighter second color in the same family
		- Typography
			- 2 different fonts are good, 3 is pushing it, 4+ is bad
			- Keep moods and time eras consistent
				- i.e. Don't mix Roaring 20's-ish font with Renaissance-ish font
			- Contrast serif-ness, (serif vs sans-serif) and font weights
		- UI Design
			- Function comes before form in all cases
			- Ingrained visual impulses
				- Eyes automatically go to biggest, boldest, brightest thing first
				- Then round things
				- Then smaller things
				- Then lighter-shaded things
			- Think of application as a journey
				- Title > Sub-title > Larger images > Smaller images > Some text
			- Minimize number of alignment lines, (horizontal & vertical)
				- More alignment lines are perceived as "messy"
			- Should work to provide conscious and subconscious queues
				- Use 3D lighting effects to make elements seem more like real world
					- Light should always come from above			
					- i.e. To improve clickthrough on clickable button
						- Unpressed state - slight shadow on bottom
						- Pressed state - no shadow
			- Start in monochrome
				- Focus on spacing / positioning, etc
				- To avoid getting distracted by colors
				- Then add a single pop of color
					- And build up color from there
			- Make sure text over images stands out / is easily readable
				- Especially where image will change
					- If image will always be static, can just mod text color
					- Make sure and test in front of a whole slew of images
				- Colored overlay above image
					- Can look a bit ugly
						- Reducing opacity can help
							- Gaussian blur has similar effect
	- Responsive Design
		- Page design changes based on viewport / screen size used, (i.e. laptop vs ipad vs phone)
			- Bootstrap, (https://getbootstrap.com/)
				- There are other front-end frameworks that perform similar tasks
					- (Bootstrap provides additional CSS functionality beyond just responsive design)
				- Navbar, (requires Javascript)
					- Navbar expands / contracts into hamburger menu
				- Grid System
					- Horizontal content broken into 12ths
						- i.e. to display 4 items per line for laptops, 3 per line for ipads and 2 per line for phones
							- Define outer div set to class="row"
								- Actual content class="[below code]"
									- col-xl-3 - 4 items per line, (12/3) for full screen desktops, (xl)
									- col-lg-4 - 3 items per line, (12/4) for full screen laptops, (lg) presuming resolution is less than desktops
									- col-md-6 - 2 items per line, (12/6) for ipads / windowed content, (md) on desktops/laptops
									- col-sm-12 - 1 item per line, (12/12) for phones, (sm)
									- Note: content class has to include space-separated codes for all scenarios desired
										- i.e. to be fully responsive, class="col-xl-3 col-lg-4 col-md-6 col-sm12"
											- If fewer scenarios specified, will only change display where specified
												- i.e. if only use "col-md-6" by itself, every viewport from medium up in size, (md, lg, xl) will show 2 per line, and below medium, (sm) will show 1 per line.
			- Media Queries
				- Choose different css selectors based on:
					- Media types, (print, screen, speech) and/or
					- Media features, (height, width, orientation, resolution)
				- Very useful for fine-tuning individual bits of design
					- i.e. use Bootstrap for broad-brush design bits
						- Then add in media queries, where desired, to finish off
				- Encase css selectors within query specifying situation they should apply to
					- i.e. @media screen (min-width: 900px) { [css selectors] }
				- If you model css selector classes identically - i.e.:
					- @media screen (min-width: 600px) {
  					  /* For tablets: */
					  .col-s-1 {width: 8.33%;}
					  .col-s-2 {width: 16.66%;}
					  .col-s-3 {width: 25%;}
					  ...
					  .col-s-12 {width: 100%;}
					  }
					 
					  @media screen (min-width: 768px) {
					  /* For desktop: */
					  .col-1 {width: 8.33%;}
					  .col-2 {width: 16.66%;}
					  .col-3 {width: 25%;}
					  ...
					  .col-12 {width: 100%;}
					  }
					
					- You can then call them exactly as with Bootstrap in html - i.e.:
						- <div class="row">
							<div class="col-3 col-s-3">...</div>
							<div class="col-6 col-s-9">...</div>
							<div class="col-3 col-s-12">...</div>
						- </div>
				- Note: css selectors inside media queries override css selectors outside - i.e.:
					- h1 {color: red;}
					- @media screen (min-width: 900) {h1 {color: blue;}}
					- If width < 900, h1's will be red.
					- If width >= 900, h1's will be blue.
	- Accessibility
		- aria-hidden="true"
			- Hides content from assistive technology, (i.e. screen reader) for this and all children elements
				- (for use with buttons, etc)
	- Javascript, (JS)
		- Good source for idiomatic js code -> https://github.com/rwaldron/idiomatic.js/
		- Document Object Model, (DOM)
			- Tree diagram of html code
			- Selecting items, (most common method)
				- document.querySelector("[element]") -> Individual Item
					- If multiples, will only return first one found
				- document.querySelectorAll("[element]") -> Array of all matching
				- [element] uses exact same selectors as CSS
					- i.e. "h1", "p.[class name]", "li a"
			- Modifying items
				- (Uses same properties as CSS, but camelCased instead of hyphenated)
					- (i.e. instead of "font-size," (CSS) it would be "fontSize," (JS))
				- For styles, best is to use ".classList.toggle[[class name]];"
					- (or ".classList.add[[class name]];"/".classList.remove[[class name]];")
					- Toggles adding/removing class selectors that exist in CSS file to items
						- (akin to how Bootstrap works)
							- i.e. add/remove a class of "invisible" or "big" or whatever
					- Lets you keep all styling in CSS file and only use JS for behavior.
				- For actual attributes, (i.e. "href=" in an anchor tag):
					- .getAttribute([attribute name])
					- .setAttribute([attribute name], [new value])
		- Event Listeners
			- When using a named function as the callback function of an event listener
				- (i.e. the function that's supposed to be called once the specified event is detected)
				- Use the function name without parenthesis, or the event will trigger on page load, rather than only when the specified event occurs, i.e.:
					- ".addEventListener('click', handle_click());" -> Triggers on page load, rather than on click, as intended.
					- ".addEventListener('click', handle_click);" -> Triggers on click, as intended.
				- Thus, if you want to actually send back the event object that triggered the callback, you have to use an anonymous, (i.e. not named) function.
					- i.e. ".addEventListener("keydown", function(event) {}"
						- Since you can't do ".addEventListener("keydown", handle_click(event));"
							- And still have it respond only to the event and not page load.
		- Constructor Functions
			- First letter of the function name has to be capitalized, i.e.
				- function Person ([name], [age], [height],...) {
				 	this.name = name;
				 	this.age = age;
				 	this.height = height;
				 	...
				  }
			- When using, have to use "new" keyword before any values passed, i.e.
				- person_1 = new Person ([name_1], [age_1], [height_1],...);
				- person_2 = new Person ([name_2], [age_2], [height_2],...);
			- To add methods, use anonymous functions, (i.e. functions without names)
				- i.e. in above Person definition, add:
					- this.[method_name] = function() {[function definition]}
				- To use for person_1, would just be "person_1.[method_name]()"
		- Functional Programming operations, (map/filter/reduce & find/findIndex)
			- .map function
				- (Has significant application in React - see ".map in React" section below)
				- Used to apply a function to each member of an array without explicit looping
					- For a given array and function definition
						- (So long as they're logically relatable - i.e. an array of ints and a mathematical function, an array of strings and a string manipulation function, etc) 
						- [Array Name].map([Function Name]) will apply [Function Name] to each member of [Array Name]
							- i.e. 	"function double(x) {
										return x * 2;
									}"
									"const numbers = [2, 12, 25, 3, 1]"

									"numbers.map(double);" // yields [4, 24, 50, 6, 2]
			- .filter function
				- Returns only values that fit a [Defined Condition]
				- Works fundamentally the same as .map
					- (Array and function definition, logically relatable, apply .filter to the array, etc)
					- Expects the function, (i.e. the [Defined Condition]) to resolve to a boolean True or False
						- Returns only values where the function evaluates to True
							- i.e. 	"function less_than_10(x) {
										return x < 10;
									}"

									"numbers.filter(less_than_10);" // yields [2, 3, 1]

									"function greater_than_or_equal_to_10(x) {
										return x >= 10;
									}"

									"numbers.filter(greater_than_or_equal_to_10);" // yields [12, 25]"
			- .reduce function
				- Converts an array to a single value by applying a function
				- Works like .map and .filter
					- Expects the function to define how to combine members of an array
						- Via an intermediate value during processing, (i.e. "accumulator")
							- i.e.	"function add_all_together(accumulator, current_number) {
										return accumulator + current_number;
									}"

									"numbers.reduce(add_all_together);" // yields 43
								- (If curious, starts by automatically setting accumulator = array[0], current_number to array[1])
									(Then sets accumultor = return value, current_number to array[2], etc)
			- .find function
				- Returns first value in an array that matches [Defined Condition]
					- i.e. 	"numbers.find(less_than_10);" // yields 2
			- .findIndex function
				- Returns index of first value in an array that matches [Defined Condition]
					- i.e.	"numbers.findIndex(less_than_10);" // yields 0
		- Arrow Notation, (/ Arrow Functions / "Fat Arrow" / "=>")
			- Way of shortening function definitions
				- From longest to shortest:
					- Named function -> function double(x) {return x * 2}
						- Delete function name to get:
							- Anonymous function -> function (x) {return x * 2}
								- Delete function keyword to get:
									- (x) => {return x * 2}
										- If function takes only one parameter:
											- x => {return x * 2}
										- If function has a single-line return statement, delete return keyword and brackets to get:
											- x => x * 2
											- (Note: can still use this return line simplification even if the function takes more than one parameter)
				- Often used to simplify Functional Programming operations, (i.e. map/filter/reduce)
					- So:
						- Instead of using:
							"function double(x) {
								return x * 2;
							}"

							"numbers.map(double);" // yields [4, 24, 50, 6, 2]
						- You just use:
							"numbers.map(x => x * 2);"// yields [4, 24, 50, 6, 2]
					- Or:
						- Instead of using:
							"function less_than_10(x) {
								return x < 10;
							}"

							"numbers.filter(less_than_10);" // yields [2, 3, 1]
						- You just use:
							"numbers.filter(x => x < 10);" // yields [2, 3, 1]
					- (Note for .reduce)
						- (Since you need to explicitly specify an accumulator parameter in addtion to the regular parameter)
							- (The shortest you can get to is:)
								- ("numbers.reduce((accumulator, current_number) => accumulator + current_number);")
		- Destructuring, (ES6)
			- Way of assigning multiple variables concurrently to multiple values in an array or object
				- If values are in an array
					- Can use any variable names you want
						- i.e. 	"const [red, green, blue] = [9, 132, 227];"  // red = 9, green = 132, blue = 227
					- If the number of variable names < number of items in the array
						- Will assign values up to the number of variable names in your definition
							- i.e. 	"const [red, green] = [9, 132, 227];"  // red = 9, green = 132; no variable is assigned to the value 227
				- If values are in an object
					- i.e. 	"const animal_one = {"name": "cat", "sound": "meow"};"  // [Given Object #1]
						- Can either use the key names already used in the object
							- i.e. 	"const { name, sound } = animal_one;  // name = cat, sound = meow
						- Or define an alias for any keys desired
							- i.e. 	"const { name: red, sound: green } = animal_one;  // red = "cat", green = "meow"
						- Can also define default values
							- "const { name = "Fluffy", sound = "Purr" } = animal_one;  // if cat/meow exists in the object, name = "cat", sound = "meow".  If it doesn't, name = "Fluffy", sound = "Purr"
					- Can, (but don't have to) nest the level of destructured variables to the levels in the object
						- i.e. 	"const animal_two = {"name": "cat", "sound": "meow", "feedingRequirements": {"food": 2, "water": 3}};  // [Given Object #2]
								"const { name, sound, feedingRequirements: { food, water }} = animal_two;"  // name = "cat", sound = "meow", food = 2, water = 3
								- (Can also ignore nested objects, and assignment still works for the non-nested key values)
									(i.e. 	"const { name, sound } = animal_two;  //  name = cat, sound = meow;  Note "= animal_two", it's using [Given Object #2], the one with the nested object "feedingRequirements", rather than [Given Object #1], the one with no nested object, and it still works
		- Spread Operator, (ES6 / "...")
			- Method of adding the elements of one array into another array, or one object into another object without nesting
				- i.e.	"const citrus = ["Lime", "Lemon", "Orange"];
						const fruits = ["Apple", "Banana", "Grapefruit", ...citrus]"
							- Yields fruits = ["Apple", "Banana", "Grapefruit", "Lime", "Lemon", "Orange"] // fruits[3] = "Lime"
								- (NOT fruits = ["Apple", "Banana", "Grapefruit", ["Lime", "Lemon", "Orange"]] // fruits[3] = ["Lime", "Lemon", "Orange"])
				- i.e.	"const full_name = {
							"first_name": "Edgar",
							"last_name": "Bergen"
						}
						const user = {
							...full_name,
							id: 1,
							username: "ebergen"
						}
							- Yields user = {"first_name": "Edgar", "last_name": "Bergen", "id": 1, "username": "ebergen"}  // user.first_name = "Edgar"
								- (NOT user = {"full_name": {"first_name": "Edgar", "last_name": "Bergen"}, "id": 1, "username": "ebergen"}  // user.first_name does not exist; user.full_name.first_name = "Edgar")
			- Can be placed at any location inside another array, (/ object, but objects don't use indices, so more for style than usefulness)
				- i.e.	"const fruits = ["Apple", ...citrus, "Banana", "Grapefruit"]"
							- Yields fruits = ["Apple", "Lime", "Lemon", "Orange", "Banana", "Grapefruit"]
		- Javascript Quirks / Things to Remember
			- Arrays
				- Can't use negative indexes
			- Constants
				- Constants aren't real constants, (i.e. they aren't immutable)
					- const [array name]
						- You can't reassign [array name] entirely, (which is good)
							- But you can still push items into it, (which is bad)
					- const [object name] = {[key], [value]}
						- You can't reassign [object name] entirely, (which is good)
						- You can't overwrite the name of [key], (which is good)
							- But you can change [value] of [key], (which is bad)
						- You can actually make [object name] immutable after the const assignment
							- By adding Object.freeze([object name])
					- To minimize developer human-expectation bugs
						- (i.e. bugs caused by developers expecting JS to behave similarly to other languages)
						- Don't use "const" keyword if the array or object isn't really immutable
							- (Note: React likes to use "const" for mutable values)
								- (So expect to see lots of mutable "const"s in React code)
									- (Eventually, will have to look more into why React thinks they should be using "const")
										- (Presuming there's an _incredibly_ strong reason to try messing with so basic a concept)
											- (But, until someone convinces me that pi or e or K have actually always been mutable variables)
												- (I, at least, will be sticking to the idea that all constants, and keywords used to refer to them, must actually be... constant...  i.e. immutable)
			- Scope
				- Javascript has three concepts of scope, instead of two:
					- Global Scope, (available everywhere)
						- var x   -> global
						- let x   -> global
						- const x -> global
					- Block-level Scope - Function code blocks only
						- (i.e. inside a code block explicitly defined by the use of the "function" keyword only)
						- var x   -> local
						- let x   -> local
						- const x -> local
					- Block-level Scope - Other-than-Function code blocks
						- (i.e. inside any code blocks NOT explicitly defined by the use of the "function" keyword)
							- (i.e. if/else, for, do/while, etc)
						- var x   -> global   // CAUTION: this is unlike some other languages, which would expect local scope in this situation
						- let x   -> local
						- const x -> local
				- To minimize developer human-expectation bugs
					- (i.e. bugs caused by developers expecting JS to behave similarly to other languages)
						(- where there is no distinction between JS' two Block-level scope types)
					- Use "let" instead of "var"
						- Which effectively makes JS behave as a two-scope language
							- ("let" was specifically added to the language in ECMAScript 6 to address this issue)
								- (Though expect to see the use of lots of "var"s in legacy, (and often, even new) code)
									- (Since:
										- ( a) "var" is still taught as the primary variable type in some places, and )
										- ( b) "var" certainly _sounds_ more natural for a variable definition than "let" )
			- Unenforced Elements 
				- ";" usage at end-of-lines not enforced
					- Can often either include an end-of-line semi-colon, or not, with no demonstrable effect on code function either way
						- And yet, ";" end-of-line is still generally preferred... sometimes...
							- Presume there's some actual syntactic value to it being there
								- But have yet to figure out in what situations that value actually exists
									- As I've yet to have something not work due to ";" inclusion or omission
				- Quoted keynames in javascript objects not enforced
					- {key1: "string_value_1", key2: numeric_value_2} is pretty much functionally equivalent to:
						- {"key1": "string_value_1", "key2": numeric_value_2}
							- Even though the "key" form, (with the quotes - i.e. where the key name itself is a string) is supposed to be the proper form.
		- jQuery
			- (Loaded via hosted library, akin to Bootstrap)
				- (i.e. <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>)
			- Simplification of pure javascript
				- "$" at the beginning of a statement signifies you're using jQuery
					- Can also embed jQuery inside javascript on the same line
						- i.e. "console.log($([element]).hasClass([class name]));"
			- Selecting items
				- "$("[element]")
					- Instead of document.querySelector("[element]")
				- No difference between selecting one, (.querySelector) or many, (.querySelectorAll) items
			- Modifying items
				- i.e. ".toggleClass('[class name]');"
					- Instead of ".classList.toggle[[class name]];"
				- Any modifications will apply to every matching item, (whether singular or in an array)
			- Adding/Removing html elements, (without altering actual html files)
				- Adding
					- Around the [element]:
						- Add [html code] immediately BEFORE [element]'s OPENING tag.
							- "$("[element]").before("[html code]");"
						- Add [html code] immediately AFTER [element]'s CLOSING tag.						
							- "$("[element]").after("[html code]");"
					- Inside of the [element]:
						- Add [html code] immediately AFTER [element]'s OPENING tag.
							- "$("[element]").prepend("[html code]");"
						- Add [html code] immediately BEFORE [element]'s CLOSING tag.							
							- "$("[element]").append("[html code]");"
					- i.e. BEFORE <h1> PREPEND [prior h1 content] APPEND </h1> AFTER
				- Removing - "$("[element]").remove();"
		- Node / Node.js
			- Allows Javascript to run outside of the browser
			- To choose version of node to run, install "n" package globally
				- "sudo npm install -g n"
				- To use latest version
					- "sudo n latest"
				- To use LTS, (Long Term Support) version
					- "sudo n lts"
			- For each new project
				- Initialize -> "npm init"
					- (inside project directory)
					- Text-based setup wizard
						- (can also type "npm init -y" to accept all wizard defaults)
						- Will create [package.json] file with results
							- For "dependencies" item:
								- Semantic Versioning
									- [Major Release Version].[Minor Release Version].[Patch Version]
										- i.e. 3.2.5
									- Bug fixes that don't break any functionality increment [Patch Version]
										- i.e. 3.2.6
									- Feature additions that don't break functionality increment [Minor Release Version]
										- i.e. 3.3.0
									- Functionality-breaking additions/subtractions increment [Major Release Version]
										- i.e. 4.0.0
								- When specifying dependency versions, three options:
									- Precise version only -> "3.2.5"
									- Precise version + [Patch Version] -> "~3.2.5"
									- Precise version + [Minor Release Version] -> "^3.2.5"
				- Install any modules needed
					- "npm install [module_name_1] [module_name_2] [module_name_3] ..."
						- To install an older version of any module
							- "npm install [module_name]@[version number]"
				- Startup -> "node [package.json "main" js file]"
					- If code inside [package.json "main" js file] would start a webserver:
						- Requires manually stopping and restarting the server for each saved change in [package.json "main" js file]
						- Nodemon
							- Drop-in webserver replacement for basic "node [package.json "main" js file]"
								- "nodemon [package.json "main" js file]"
									- (To install -> "npm install -g nodemon")
							- Automatically stops and restarts server with every saved change in [package.json "main" js file]
			- Express
				- Node framework analogous to jQuery for Javascript
				- Issues @ 2020-05-22
					- Express uses symlinks when installing, which will not work on FAT32/NTFS volumes
						- (FAT32/NTFS volumes don't allow creation of Linux symlinks)
					- npm has a --no-bin-links flag which should deal with this, but the flag doesn't work
						- (Hasn't worked since at least 2014...  :/ )
					- Workaround
						- Create [twin project directory] on a drive that does create proper symlinks, (i.e. ext4, zfs)
						- Install Express, (and every other non-global module you need for that project) in [twin project directory]. 
						- Delete any prior /node_modules/ directory in [FAT32 project directory]
						- Use rsync to create a copy in [FAT32 project directory], converting symlinks to normal files/directories.
							- "rsync -avL ./node_modules [FAT32 project directory]"
						- cp [twin project directory]/package.json and [twin project directory]/package-lock.json to [FAT32 project directory]
				- Enabling, (add below inside [package.json "main" js file]):
					- const express = require("express");
					  const app = express();
					- Enable static file, (i.e. css, images, etc) access from the outside world
						- In [project directory]
							- "mkdir public"
							- Move all css, image and other static files into [project directory]/public
						- In [package.json "main" js file]
							- "app.use(express.static('public'));"
								- Note: for html link purposes, this will make [project directory]/public considered to be in the same directory as .html(/.ejs) files being rendered
									- i.e. If styles.css actually exists at [project directory]/public/css/styles.css and
										- index.html actually exists at [project directory]
										- After adding the express.static setting, the css link inside index.html:
											- SHOULD BE: "<link rel="stylesheet" href="css/styles.css">"
												- (as if the css subdirectory was directly in [project directory], even though it's not)
											- NOT: "<link rel="stylesheet" href="/public/css/styles.css">"
												- (which is where the file actually is)
					- app.listen([port number]) sets port server will respond on
					- Add routes, (/url permutations) that you want to respond to
						- (if files) app.[HTTP method]([route], function(request, response) {
							response.sendFile(__dirname + "/[relative path to file to send]");
						}) OR (if text) app.[HTTP method]([route], function(request, response) {
							response.send("[random text]");
							- (__dirname is a special Node variable equal to the absolute directory of the current working directory)
							- Where [HTTP method] = "post", "get", "put" or "delete"
								- (corresponding to "create", "read", "update" and "delete" operations)
								- i.e. (if files) app.get("/", function(request, response) {
									response.sendFile(__dirname + "/index.html");
								  }) OR (if text) app.get("/", function(request, response) {
									response.send("Hello World");
							- [route] examples:
								- "/" - home route
									- i.e. responds to the base url of your website
								- "/contact" -> [base url]/contact
								- "/about" -> [base url]/about
							- Chaining Route Handlers
								- Where the route is identical, (i.e. '/articles') rather than having entirely separate route handlers for each [HTTP method]
									- i.e. app.get('/articles', ...), then app.post('/articles', ...), then app.put('/articles', ...)
								- Can "chain" them together via app.route, i.e.
									- app.route('/articles)
									-     .get(function(req, res) { ...
									-     .post(function(req, res) { ...
									-     .put(function(req, res) { ...
										- Note: Only put a ";" at the end of the last "chained" route, (i.e. after the .put)
						- Note: Can only have one response.send/.sendFile per route)
						- Route parameters
							- Let's you define one route to respond to multiple url strings using variables
								- app.[HTTP method]('/[fixed portion of url]/:[variable name for variable portion of url], function (req,res) { ...  
									- i.e. In [package.json "main" js file]
										- app.get('/users/:user_name', function (req, res) { ...
									- Which would respond to "[base url]/users/jane" in a browser window
									- Access [variable name for variable portion of url] via req.params.[variable name for variable portion of url]
										- i.e. req.params.user_name = "Jane"
									- Can respond to multiple fixed or variable portions of the url if desired
										- i.e. app.get('/users/:user_name/book/:book_id', ... )
									- [variable name for variable portion of url] can be made optional by adding "?" at the end
										- i.e. app.get('/users/:user_name?', function (req, res) { ...
											- Which will respond to either
												- "[base url]/users/jane" OR "[base url]/users"
										- Note: if a variable is optional, will need to add an if test for the variable being missing in the url string
											- This test must test for the type of the variable being undefined, rather than the value of the variable being null, (which are apparently different...)
												- i.e. if (typeof(req.params.user_name) === 'undefined') { ...
				- Client/server interation
					- Client, (displaying html file you sent -> [__dirname + "/[html file]"]), i.e:
						- <form action="/" method="post">
        					  	<input type="text" name="num1" placeholder="First Number">
        					  	<input type="text" name="num2" placeholder="Second Number">
        					  	<button type="submit" name="submit">Calculate</button>
    					  	  </form>
					- Server
						- Body Parser, (npm install body-parser)
							- In [package.json "main" js file]
								- "const body_parser = require("body-parser");"
								- (below the "const app = express();" line)
									- "app.use(body_parser.urlencoded({extended: true}));"
										- (several .[X] parser types)
								- Do whatever you want with the received data inside the app.post route, i.e:
								- app.post("/", function(req, res) {
									let num1 = Number(req.body.num1);
									let num2 = Number(req.body.num2);

									let result = num1 * num2;
									res.send("The result of the calculation is " + result);
								})
									- (Note: body-parser returns parsed items as strings by default)
						- Remote Elements, (via API)
							- (Using Node's https module)
							- https.get([url], function(response) {
								response.on([information desired from API response, often "data"], function(data) {
									JSON.parse(data);
								})
							})
								- (Note: "data" in above function arrives in hexadecimal format, hence use of [X].parse, where "data" is in [X, often "JSON"] format)
						- Templating
							- EJS, (Embedded JavaScript Templating)
								- Create "views" subdirectory in [project directory]
									- (precise directory name important - "views")
									- Make any html files in [project directory]/views with an ".ejs" extension, (instead of ".html")
										- To populate values from your [package.json "main" js file]
											- Add "<%= [variable name] %>"
										- To add control flow, (and only control flow) logic
											- (i.e. to change the way an element is rendered based on the result of [variable name])
											- Add "<%" and "%>" at the beginning and end of every single line of javascript only
												- (i.e. do not add to any lines with html tags), i.e.:
													- <% for(let i = 0; i < items.length; i++) { %>
            											<li><%= items[i] %></li>
        											  <% } %>
											- NOTE: When trying to comment out lines with <% %>
												- EJS will not respect regular html comment tags, (i.e. "<!--" "-->")
													- Meaning the line of javascript you just tried to comment out will still run
												- To actually stop lines with <% %> from running
													- You have to manually add javascript comment tags, (i.e. "//") AFTER the opening "<%"
								- In [package.json "main" js file]
									- To enable
										- "const ejs = require('ejs');"
										- (below the "const app = express();" line)
											- "app.set('view engine', 'ejs');"
									- To return information via a route
										- "res.render('[name of specific /views ejs file, without ejs extension - i.e. 'index'], {[variable name used in ejs file]: '[variable name used in [package.json "main" js file]]'});"
											- i.e. "res.render('index', {day: day});"
								- Layouts, (/Partials)
									- In Views directory
										- Create .ejs files to hold whatever commonly-repeated portions of pages you want
											- i.e. "header.ejs" and "footer.ejs"
										- Put repeated portions from [Main].ejs file into appropriate alternate .ejs files, i.e.:
											- In header.ejs
												- <!DOCTYPE html>
												  <html lang="en">
												  <head>
													  <meta charset="UTF-8">
													  <meta name="viewport" content="width=device-width, initial-scale=1.0">
													  <title>[Appropriate Title]</title>

													  <link rel="stylesheet" href="css/styles.css">
												  </head>
												  <body>
											- In footer.ejs
												- </body>
												  </html>
										- In [Main].ejs file
											- "<%- include('header') -%>" where header info used to be
											- "<%- include('footer') -%>" where footer info used to be
			- Modules, (local)
				- Way of externalizing bits of code for reuse / refactoring
				- Works same as any npm-installed module
					- (Other than requiring the absolute module filename, (local) vs module name, (npm))
					- In [package.json "main" js file]
						- Require module
							- const [constant name] = require(__dirname + "/[module filename relative to project directory]);
								- i.e. "const date = require(__dirname + "/date.js");"
						- Use functions in the module
							- [constant name].[function name WITHOUT parenthesis]();
								- i.e. "date.get_date();"
					- In [module filename relative to project directory]
						- Bundle desired functionality inside anonymous function(s) with appropriate return(s)
						- Connect anonymous function(s) with exports.[function name WITHOUT parenthesis]
							- i.e. "exports.get_date = function() {
								  	    [whatever get_date actually does, including return statement]
							  		};"
							- Gives [package.json "main" js file] access to function(s) return(s)
			- (Github)
				- Hiding API keys, (and other sensitive info)
					- Add ".env" file to [project directory]
					- Add ".env" line to .gitignore
						- (will keep any .env files from being committed)
					- Store any secret info in ".env"
						- In the form of one CAPITALIZED_KEYNAME='value' per line
					- npm install dotenv
					- In [package.json "main" js file]
						- "const dotenv = require('dotenv').config();"
						- Values of all .env key/value pairs available as "process.env.[CAPITALIZED_KEYNAME]"
				- Add 'node_modules' to .gitignore to avoid committing files generated by npm init.
					- To regenerate node_modules, including all dependencies, just type "npm install" with no arguments in [project directory]
						- Equivalent of "npm init" plus "npm install [modules]" for all [modules] in package.json / package-lock.json files in [project directory]
	- Testing
		- Creating Tests
			- Using Jest
				- npm install -g jest
				- In same directory as [js file to be tested].js
					- Add test.js file
						- "const [appropriate name for what project does] = require('[js file to be tested, including relative path from test.js, but excluding the ".js" extension - i.e. "./index" ]');"
						- Add all appropriate tests, with a line between each, in the form:
							- 	"test('[Individual human-readable test name]', () => {
									expect([function to be tested]('[argument(s) to pass to function]')).toEqual('[expected return value]');
								});"
				- Run tests from the directory above where the test.js file is located
					- "jest [directory name where test.js file is located]"
		- Debugging, (/ node inspect)
			- For the test(s) that are failing
				- Directly below the line where you want code execution to pause, add a (temporary) "debugger;" statement as a separate line
				- Add a (temporary) function call for [function to be tested]('[argument(s) to pass to function]') after the function definition.
					- But before the "module.exports = [function to be tested];" line
					- So that the function is actually invoked and can thus be inspected
						- If you don't put this (temporary) function call in, there is nothing in the file for node to inspect
				- Then tell node to start running the code in break mode
					- "node inspect [js file to be tested].js"
				- Node will stop execution at the first "debugger;" statement it finds and give you a "debug>" prompt
					- "cont" / "c" will tell Node to move to the next "debugger;" statement
					- "repl" will enter a Node debug repl where you can check what the values of any variables are at that point of execution
						- By just typing the name of the variable
						- When you've seen enough and want to move on to the next break point
							- Press "Ctrl + C" to exit the Node debug repl
								- Which will return you to the "debug>" prompt
					- "Ctrl + C" twice / ".exit" will exit "debug>" prompt
				- When done debugging
					- Remove all "debugger;" statements
					- Remove (temporary) function call
						- That you put after the function definition
							- But before the "module.exports = [function to be tested];" line
	- Deployment
		- Heroku
			- Prep for deployment
				- In [project directory]
					- Add file named "Procfile" to [project directory] that contains command to start app
						- i.e. "web: node index.js"
					- Mod app.listen to use process.env.PORT environment variable
						- (either adding "PORT=[desired local port number] to .env), or
						- ("app.listen((process.env.PORT || 3000),...))
							- (where [desired local port number] = 3000)
					- Add node version to package.json
						- "engines": {
							"node": "14.x" // (or whatever version of Node you're using)
						  }
				- Heroku Dashboard > "Settings" tab
					- Manually enter any needed environment variables, (from .env file) as "Config Vars"
			- Deploy
				- Through Github
					- Heroku Dashboard > "Deploy" tab
						- (Authorize Heroku to access your Github account)
						- Add repo name to "Connect to Github" section
						- Enable automatic deploys
							- Every commit to master will automatically push to Heroku
						- Or leave unchecked and manually deploy via "Deploy a Github branch"
							- Can also be used to deploy branches other than master.
				- Through command line
					- install heroku, (see heroku.com for details)
					- In [project directory]
						- "heroku create" to add heroku git remote
						- "git push heroku master"
	- Databases
		- SQL vs NoSQL
			- SQL, (/Relational)
				- Most popular: MySQL, (Postgres)
				- Stores records as entries in (multiple) tables linked by formal relationships
					- All entries have to have all attributes, (even if attribute = Null)
				- Pros
					- Very good in situations where a (relatively) larger number of entities generate few records
						- i.e. ecomm, (/Customers/Products/Orders)
					- Search speed for complex queries faster
			- NoSQL, (/Non-Relational)
				- Most popular: MongoDB, (Redis)
				- Stores records as JSON objects
					- Entries can have as many or as few attributes as relevant
						- Easier to make adjustments if requirements frequently change
					- Can still specify relationships between JSON objects via attributes, but not as efficient for complex queries
				- Pros
					- Very good in situations where a (relatively) smaller number of entities generate a lot of records
						- i.e. Blog posts / Twitter / Instagram
					- Cheaper to scale
						- i.e. Scales well horizontally
		- SQL
			- Table level
				- Create table
					- CREATE TABLE [table name] (
					  [column name 1 - i.e. "id"] [datatype 1 - i.e. "INT"] [column traits - i.e. "NOT NULL"],
					  [column name 2] [datatype 2],
					  ...
					  PRIMARY KEY ([primary key column name - i.e. "id"]) // optional
					  FOREIGN KEY ([local table column name]) REFERENCES [foreign table name]([foreign table column name]) // establishes relationships between tables.
					  )
				- Add columns to a table
					- ALTER TABLE [table name]
					  ADD [column name] [datatype];
				- Delete table
					- DROP TABLE [table name];
			- Record level, [CRUD]
				- [Crud] Create record(s) in table
					- INSERT INTO [table name] ([column name 1], [column name 2], ...)
					  VALUES ([value 1], [value 2], ...);
				- [cRud] Read record(s) from table
					- SELECT [column name 1], [column name 2], ... from [table name]
					  WHERE [column name(s)] = [value(s) that select only relevant records]
				- [crUd] Update value(s) in a table
					- UPDATE [table name]
					  SET [column name]=[value]
					  WHERE [column name(s)] = [value(s) that select only relevant records];
				- [cruD] Delete record(s) from table
					- DELETE FROM [table name]
					  WHERE [column name(s)] = [value(s) that select only relevant records]
			- Joins
				- Types
					- INNER JOIN = records exist in both tables
						- Left table record count = right table record count
						- Venn diagram = left table - union only, right table - union only
					- LEFT JOIN = all records from first, (i.e. left-most) table and values from second, (i.e. right-most) table where they exist
						- Left table record count >= right table record count
						- Venn diagram = full left table, right table - union only
					- RIGHT JOIN = (reverse of left)
						- Left table record count <= right table record count
						- Venn diagram = full right table, left table - union only
					- FULL OUTER JOIN = all records from left and right, connected where joined columns are equal
						- Left table record count + right table record count, including union
						- Venn diagram = full left table, full right table
				- SELECT [table name that contains foreign key definitions].[column name 1], [table name that doesn't contain foreign key definitions].[column name 3]
				  FROM [table name that contains foreign key definitions]
				  INNER JOIN [table name that doesn't contain foreign key definitions] ON [table name that contains foreign key definitions].[appropriate foreign key column name] = [table name that doesn't contain foreign key definitions].[column name in this table that matches foreign key in other table]
		- MongoDB
			- In Mongo Shell
				- Database level
					- Use, (/create) db => "use [database name]"
						- Confirm by showing current database => "db"
						- Note: if [database name] does not exist, it will automatically be created.
					- Delete db
						- use [database name that you want to delete]
						- db.dropDatabase()
				- Collection / Table level
					- Show all collections / tables => "show collections"
					- Relationships, (i.e. SQL Foreign Key "equivalent")
						- Preferred => Embed "sub-documents" directly into relevant records as an array, i.e.:
							- 	reviews: [
									{
										author: "Sally",
										rating: 5,
										review: "Best doodad ever!"
									},
									{
										author: "John",
										rating: 5,
										review: "Awesome doodad!"
									}
								]
						- Can also => Manually reference records in other collection(s) / table(s), i.e. in db.orders:
							- 	{
									order: 2541,
									products_id: [1, 2],  //  where [1, 2] = db.products.find({_id: 1}) & db.products.find({_id: 2})
									users_id: 245  //  where 245 = db.users.find({_id: 245})
								}
				- Record level, [CRUD]
					- [Crud] Create record(s)
						- db.[collection / table name].insertOne(   // or db.[collection / table name].insertMany( 
							{[JSON object(s)]}  // i.e. name: sue, age: 26, status: "pending"
							)
							- Note: if [collection / table name] does not exist, it will automatically be created.
							- Note: "_id" is the default primary key field.
					- [cRud] Read
						- db.[collection / table name].find(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause, optional
							{ [key_1]: 1, [key_2]: 1}  // 1 = true / yes, return this field, optional 
							).limit([max records to retrieve])  // limit, optional
						- db.[collection / table name].find()
							- Select * from [collection / table name] equivalent
					- [crUd] Update
						- db.[collection / table name].updateOne(  // or db.[collection / table name].updateMany(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause
							{ $set: { [key]: [value] } }
							)
					- [cruD] Delete
						- db.[collection / table name].deleteOne(  // or db.[collection / table name].deleteMany(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause
							)
			- Mongoose
				- Connect to database
					- 	"const mongoose = require('mongoose');"
						"mongoose.connect('mongodb://[mongodb access url:port]/[database name]', [deprecation warning items, if any]);"
							- i.e. mongoose.connect('mongodb://localhost:27017/fruits_db', { useUnifiedTopology: true });
				- Create database schema to define the structure of all new records, (/documents) that will be added to the database.
					- Adding validation rules and relationships to other schemas, where desired
						- Note: Any relationships defined will really just embed foreign schema objects into the current record, akin to the "sub-documents" discussed in the "In Mongo Shell" section, above.
							- And, unless both aspects of the relationship, (i.e. the local object and the foreign schema object) are created and saved in the exact same run of index.js, (which will probably be extremely rare) though the data embedded will mostly be the same, the _id's of the object and its embedded counterpart will be different
								- So you won't be able to later query the _id of the embedded object and use that to query the table/collection that embedded object came from to get the original object
					- 	"const [schema name] = new mongoose.Schema ({
							[schema key_1]: {  // longer form, with validation
								type: [datatype],
								[validation_type_1]: [value],  // all validation_types are optional
								[validation_type_2]: [value],  // all validation_types are optional
							[schema key_2]: [datatype],  // shorter form, without validation
							...
							[local name for foreign schema object 1]: [foreign schema name]
						})"
							- i.e. const fruit_schema = new mongoose.Schema ({
								name: {  // validation
									type: String,
									required: true
								},  
								rating: {  // validation
									type: Number,
									min: 1,
									max: 10
								},
								review: String  // no validation,
								primary_pollenator: pollenator_schema
							});
				- Create model to define tables / collections
					- 	"const [capitalized model name] = mongoose.model([singular version of table/collection name - i.e. 'fruit' for a table/collection name of 'fruits'], [schema name]);"
							- i.e. const Fruit = mongoose.model('fruit', fruit_schema);
				- [Crud] Create actual record(s), (/document(s))
					- Create records to be saved to database
						- 	"const [record name] = new [capitalized model name] ({
								[schema key_1]: [value],
								[schema key_2]: [value],
								...
								[local name for foreign schema object 1]: [object created from foreign schema]
							});"
								- i.e. const apple = new Fruit ({
									name: "Apple",
									rating: 7,
									review: "A solid fruit",
									primary_pollenator: bee  // where bee was created via "const bee = new Pollenator ..."
								});
					- Save record(s) / document(s) to the database
						- Single item
							- "[record name].save();"
						- Multiple items
							- 	"[capitalized model name].insertMany([array of [record names] to be added], function(err) {
									if (err) {
										[error handling for failure to save records]
									} else {
										[success handling for saving records]
									}
								});"
									- i.e. Fruit.insertMany([kiwi, orange, banana], function(err) {
										if (err) {
											console.log(err);
										} else {
											console.log("Successfully added fruits");
										}
									});
				- [cRud] Read data from db to confirm all records saved
					- 	"[capitalized model name].find(function(err, [array name for [record names] to be retrieved]) {
							if (err) {
								[error handling for failure to retrieve records]
							} else {
								[success handling for retrieving records]
							}
						});"
							- i.e. Fruit.find(function(err, fruits) {
									if (err) {
										console.log(err);
									} else {
										console.log(fruits);
									}
							});
				- [crUd] Update record(s) in database, if necessary
					- 	"[capitalized model name].updateOne(   // or .updateMany(
							{[query parameters to locate record to be updated]},
							{[key_to_update_1]: [value_to_update_to_1], [key_to_update_2]: [value_to_update_to_2]},
							function(err) {
								if (err) {
									[error handling]
								} else {
									[success handling]
								}
						});"
							- i.e. Fruit.updateOne(
								{_id: 1},
								{name: peach},
								function(err) {
									if (err) {
										console.log(err);
									} else {
										console.log("Successfully updated record");
									}
							});
				- [cruD] Delete record(s)
					- 	"[capitalized model name].deleteOne(   // or .deleteMany(
							{[query parameters to locate record to be updated]},
							function(err) {
								if (err) {
									[error handling]
								} else {
									[success handling]
								}
						});"
							- i.e. Fruit.deleteOne(
								{_id: 1},
								function(err) {
									if (err) {
										console.log(err);
									} else {
										console.log("Successfully deleted record");
									}
							});
				- Close connection to database inside last interaction with database
					- 	"mongoose.connection.close();"
						- i.e. Fruit.deleteOne(
							{_id: 1},
							function(err) {
								if (err) {
									console.log(err);
								} else {
									console.log("Successfully deleted record");
									mongoose.connection.close();
								}
						});
						- Note: if done on its own, (i.e. not inside last interaction, as shown above) even if the command is at the very bottom of the index.js file, will throw one heck of a MongoError
			- Deployment
				- MongoDB Atlas, (cloud-hosted MongoDB service)
					- Add cluster, (free vs paid)
						- Select Cloud Provider, (AWS vs Google Cloud vs Azure)
						- Select Cluster Tier, (M0 = free)
						- Select version of MongoDB, (default fine)
						- Change Cluster Name, if desired
						- Click "Create cluster"
						- Set IP Whitelist to allow connection from wherever desired, (can be "from anywhere")
					- Add [mongodb user]
					- Connect to Cluster
						- From cluster webpage
							- Click "Connect"
								- Mongo Shell
									- Copy / paste connection string to terminal
								- Application
									- Copy / paste string to .env environment variable, changing:
										- "<password>" to [mongodb user's password]
										- "<database>" to [app's desired database name]
										- i.e. "mongodb+srv://[mongodb user]:[mongodb user's password]@[mongodb cluster url]/[app's desired database name]?retryWrites=true&w=majority 
									- Adjust mongoose.connect string to use new environment variable
										- i.e. "mongoose.connect(process.env.MONGODB_LOCATION_PRODUCTION, ...);"
									- Restart node server
	- API
		- RESTful
			- Client Request
				- Use HTTP request verbs
					- Get (cRud)
					- Post (Crud),
					- Put (crUd)
						- Updates / overwrites the entire record(s)
					- Patch (crUd)
						- Updates / overwrites only a portion of the record(s)
					- Delete (cruD)
				- Use specific pattern of routes / endpoint URLs
					- /articles => performs HTTP verb on all articles
					- /articles/george_washington => performs HTTP verb on individual "george_washington" article
				- Test via cURL, (or Postman, if you prefer GUI-based)
					- -X [HTTP verb other than GET, (GET is presumed)]
						- (Note: if you pass a -d / --data-binary, cURL presumes a POST, so -X flag not explicitly required)
					- -H "Content-Type: application/[x-www-form-urlencoded, json]"
					- -d / --data-binary '[raw data (-d) / filename of datafile (--data-binary) to pass]
						- x-www-form-urlencoded => '[key1]=[value1]&[key2]=[value2]&...'
							- i.e. 'id=5&title=my%20title'
						- json => '{"[key1]": "[value1], "[key2]": "[value2]"}'
							- i.e. '{"id": 5, "title": "my title"}'
						- datafile => @[filename]
							- i.e. @my_data_file.json
					- [URL to communicate with]
					- i.e. "curl -X POST -H "Content-Type: application/json" -d '{"id": 5, "title": "my title"}' http://localhost:3000/articles"
						- OR "curl -X POST -H "Content-Type: application/json" --data-binary @my_data_file.json http://localhost:3000/articles"
			- Server Response
				- /articles
					- GET => Show all articles
					- POST => Create one new article
					- PUT => N/A, (/undefined)
					- PATCH => N/A, (/undefined)
					- DELETE => Deletes all articles
				- /articles/george_washington
					- GET => Gets the article on george_washington
					- POST => N/A, (/undefined)
					- PUT => Updates the entire article on george_washington
					- PATCH => Updates a portion of the article on george_washington
					- DELETE => Deletes the article on george_washington
				- Add body-parser parsers to [package.json "main" js file] to correlate to HTTP Content-Types you wish to support
					- application/x-www-form-urlencoded
						- "app.use(body_parser.urlencoded({extended: true}));"
							- (also used to serve regular HTML)
					- application/json
						- "app.use(body_parser.json());"
					- Note: can have more than one parser enabled at a time.  
						- The Content-Type passed in the request header will determine which one should be used by that request.
	- Encryption & Authentication, (six levels of progressively stronger encryption)
		- (Level 1) Store plain-text info in database, (don't do this! ;) 
		- (Level 2) Using Encryption Keys
			- Using mongoose-encryption module
				- npm install mongoose-encryption
				- "const encrypt = require('mongoose-encryption');"
				- Generate encryption keys
					- Either:
						- Pair of base64 strings, (32-byte encryption key and 64-byte signing key), OR
							- Can be anything, but openssl very good for easily generating (pseudo-)random strings
							- In Terminal
								- "openssl rand -base64 32"
									- Save to .env file, (making sure to delete line breaks, if they exist)
										- i.e. ENCRYPTION_KEY = [random sigils in terminal as a result of the openssl ...32 command]
								- "openssl rand -base64 64"
									- Save to .env file, (making sure to delete line breaks, if they exist)
										- i.e. SIGNING_KEY = [random sigils in terminal as a result of the openssl ...64 command]
						- Single key of any length
							- Can be anything
				- Use encryption keys to encrypt mongoose.Schema, i.e.:
					-	"const user_schema = new mongoose.Schema({
							email: String,
							password: String
						});

						// Middleware for hashing
						const encryption_key = process.env.ENCRYPTION_KEY
						const signing_key = process.env.SIGNING_KEY

						// This adds _ct and _ac fields to the schema, as well as pre 'init' and pre 'save' middleware,
						// and encrypt, decrypt, sign, and authenticate instance methods
						user_schema.plugin(encrypt, {encryptionKey: encryption_key, signingKey: signing_key, encryptedFields: ['password']});"
					- Note: These lines need to be added before the new mongoose.model
					- Will automatically encrypt on every save command and automatically decrypt on every find command
						- Note: On find commands, only decrypts the return object(s), so:
							- Searching for a user(s) via unencrypted fields and then testing those results for decrypted fields will work, i.e.
								- 	"User.findOne({email: req.body.username}, function(err, found_user) {  // email is unencrypted
										if (found_user.password === req.body.password) { ..."  // password is encrypted
							- But using encrypted fields in the find command itself will not
								- 	"User.findOne({email: req.body.username, password: req.body.password}, function(err, found_user) { ..."  // email is unencrypted, password is encrypted
				- Vulnerabilities
					- If keys are obtained, all encrypted info can be immediately decrypted
		- (Level 3) Hashing
			- Mathematical function that can be very quickly applied to info that you want to protect to create a new, encoded, value
				- But takes much, much longer, (hopefully longer than would be worth the time to do) to reverse apply to the new, encoded, value to get back to the info that you wanted to protect
				- Will always yield the exact same new, encoded, value for each given input value
					- i.e. if given "123456," md5(123456) will always be the exact same string
			- Removes need for the weak link of an encryption key
				- That, once acquired, allows for full decryption of sensitive info
			- Using md5 module
				- "npm install md5"
				- "const md5 = require('md5');"
				- Save hashed password, (/other fields)
					- Simply apply md5 function to the password before saving
						- i.e. "password: md5(req.body.password) ..."
				- Find (/match) to hashed values in database
					- Simply apply md5 function to the unencrypted value and then compare that to the hashed value in the database
						- i.e. "if (md5(req.body.password) === found_user.password) { ..."
				- Don't need to worry about searching with unencrypted values first, then testing encrypted values as a second item, as above in the (Level 2) Encryption section
					- i.e. Both of the below will work, so just up to coding preference
						- 	"User.findOne({email: req.body.username}, function(err, found_user) {  // email is unencrypted
								if (found_user.password === md5(req.body.password)) { ..."  // password is encrypted
						- 	"User.findOne({email: req.body.username, password: md5(req.body.password)}, function(err, found_user) { ..."  // email is unencrypted, password is encrypted
			- Vulnerabilities
				- Subject to dictionary / brute force attacks
					- Since so many people use common (and simple) passwords
						- And hashing always returns the exact same encrypted string
							- Hackers can simply create a table that lists common words, passwords, addresses, etc, (i.e. a dictionary) and those passwords' hashed values
								- And can simply search any obtained hashed values against the hashed value column of that table to figure out original password
								- (Calculating md5 hashes for 20 billion potential passwords / dictionary entries to create such a table can be processed in ~1 second on modern GPUs)
		- (Level 4) Salting and Hashing
			- Salting = creating a random string for each password/value to be encrypted, which is then appended to it
				- With the concatenation then hashed
					- Since this new concatenation is a much longer / more unique password than what the user would have used
						- Much less vulnerable to dictionary attacks.
				- The "salt"/random string for each password/value to be encrypted is then stored in the database
					- Where it can be concatenated and hashed as needed
				- Makes any password significantly more unique, and thus much more difficult to perform a dictionary attack against.
					- But still potentially subject to dictionary attacks if hashes can continue to be calculated very quickly
						- i.e. md5 -> 20 billion/second
					- Could make dictionary attacks less likely:
						- If a much less efficient hashing algorithm was chosen
							- i.e. bcrypt -> 17000/second
						- If multiple "Salt Rounds" were performed, i.e.
							- Take [password], generate [salt], append [salt] to [password], hash [password+salt] to generate [hashed_string_1]
							- Take [hashed_string_1], append [salt], hash [hashed_string_1+salt] to generate [hashed_string_2]
							- Take [hashed_string_2], append [salt], hash [hashed_string_2+salt] to generate [hashed_string_3]
							- ....
			- Using bcrypt module
				- Note: bcrypt is only released for stable versions of Nodejs
					- Should be even-numbered releases
						- As of 2020-09-15, though, the Current version is 14.10.1, which should be stable
							- But there is no version of bcrypt listed on their website for version 14
								- So reverted to the LTS version, (12.18.3) via the npm n module
									- In Terminal: "sudo n lts"
				- "npm install bcrypt"
				- "const bcrypt = require('bcrypt');"
				- "const salt_rounds = [number of salt rounds to use - 10 is a solid first choice];"
					- i.e. "const salt_rounds = 10;"
				- To store salted and hashed password, (/other field) in MongoDB
					-	".post(function(req, res) {
        					bcrypt.hash(req.body.password, salt_rounds, function(err, hash) {
								const new_user = new User({
									email: req.body.username,
									password: hash
								});
								new_user.save(function(err) {
							..."
				- To compare entered password to salted and hashed password, (/other field) in MongoDB
					-    ".post(function(req, res) {
        					User.findOne({email: req.body.username}, function(err, found_user) {  
            					if (found_user != null) {
                					bcrypt.compare(req.body.password, found_user.password, function(err, result) {
									if (result === true) {
										// TO DO when passwords match
                    				} else {
										// TO DO when passwords DON'T match 
									}
							..."
					- Note: we're back to testing email first, password as second call.
				- Note: the bcrypt module combines the salt with the hash and stores both values as the hash/password, (/other field) in the database
					- From which it automatically parses the two parts as / when necessary.
		- (Level 5) Cookies and Sessions
			- Using passport module, (passportjs.org)
				- "npm install passport passport-local passport-local-mongoose express-session"
					- (Note: 'express-session' NOT 'express-sessions')
						- (Possible aid in making sure you're using the right package: check weekly downloads on Github) 
				- 	"const session = require('express-session');"
					"const passport = require('passport');"
					"const passport_local_mongoose = require('passport-local-mongoose');"
						- (Note: 'passport-local' is a dependency of 'passport-local-mongoose,' but is never called directly in the code, so doesn't need to be explicitly required)
				- (At end of app.use section)
					- 	"app.use(session({
    						secret: process.env.SESSION_SECRET,
    						resave: false,
    						saveUninitialized: false
						}));"
							- (Where SESSION_SECRET in the .env file is any string)
								- (Can generate via "openssl rand -base64 32" / "openssl rand -base64 64")
						"app.use(passport.initialize());"
						"app.use(passport.session());"
				- (After "const [Mongoose Schema Name] = new mongoose.Schema({ ..." )  // Creating the schema
					- 	"[Mongoose Schema Name].plugin(passport_local_mongoose);"
						- i.e. "user_schema.plugin(passport_local_mongoose);"
				- (After "const [Mongoose Model Name] = new mongoose.model('[Mongoose Model Name]', [Mongoose Schema Name]);")  // Creating the model, using the above schema
					-	i.e. "const User = new mongoose.model('User', user_schema);"
					-	"passport.use([Mongoose Model Name].createStrategy());"
						- i.e. 	"passport.use(User.createStrategy());"
					-	"passport.serializeUser(function(user, done) {
							done(null, user.id);
						});"
					- 	"passport.deserializeUser(function(id, done) {
							User.findById(id, function(err, user) {
								done(err, user);
							});
						});"
				- To register new user
					-	".post(function(req, res) {
        					User.register({username: req.body.username}, req.body.password, function(err, user) {
								if (err) {
									console.log(err);
									res.redirect('/register');  // Or wherever the register route is
								} else {
									passport.authenticate('local')(req, res, function() {
										res.redirect('/[Whatever route is for your authenticated users only]');
											// i.e. "res.redirect('/secrets');"
									})
								}
							});
						});"
				- To login pre-registered user
				    -	".post(function(req, res) {
							const login_user = new User({
								username: req.body.username,
								password: req.body.password
							});
							req.login(login_user, function(err) {
								if (err) {
									console.log(err);
									res.redirect('/login');  // Or wherever the login route is
								} else {
									passport.authenticate('local')(req, res, function() {
										res.redirect('/[Whatever route is for your authenticated users only]');
											// i.e. res.redirect('/secrets');
									});
								}
							});
						});"
				- To test whether a user is authenticated before displaying [Whatever route is for your authenticated users only]
					- 	"app.route('/[Whatever route is for your authenticated users only]')
							// i.e. "app.route('/secrets')"
    						.get(function(req, res) {
								if(req.isAuthenticated()) {
									res.render('secrets', {
										user_email: req.user.username
									});
								} else {
									res.redirect('/login');
								}
							});
				- To log user out
					- 	"app.get('/logout', function(req, res) {
							req.logout();
							res.redirect('/');
						});"
		- (Level 6) Third Party Oauth 2.0 / Social Signins
			- Why Oauth?
				- Developer can ask User for access to only very specific bits of information
				- Developer can ask User for Read-only or Read/Write access
				- User can revoke any permissions granted to anyone from authorizing website
					- i.e. Google, Facebook, Twitter, etc
			- How to Enable
				- Step 1 - (one-time/website) Set up your application on website with which you will be using Oauth, (Google, Twitter, et al)
				- Step 2 - Redirect User to website of trusted party to authenticate
				- Step 3 - User logs in on trusted party's website
				- Step 4 - (one-time/website) User reviews / grants permissions you're requesting
				- Step 5 - Receive Authorization Code, (AuthCode) from third party website, confirming User
				- Step 6 - (one-time/website) Exchange AuthCode for Access Token
					- Store in db to access user's third-party account to retrieve any User-granted info without User
			- Using passport module
				- (See Level 5 for initial passport installation and configuration)
				- Pick Passport "Strategy" for website you want to authorize with from passportjs.org
					- Install Passport strategy module shown for the desired website, (i.e. passport-google-oauth)
						- i.e. "npm install passport-google-oauth20"
					- And mongoose-findorcreate module to make registering or logging in a single command, (akin to upsert)
						- (Passport strategy docs show a .findOrCreate pseudocode method that doesn't actually exist to just tell you you have to implement this functionality.  Luckily, someone simply turned the pseudocode call into an actual module so that you don't ;)  )
						- i.e. "npm install mongoose-findorcreate"
						- "const findOrCreate = require('mongoose-findorcreate');"
							- (Note: this module seems to insist on the const explicitly being named "findOrCreate".  Any other name, i.e. "find_or_create", comes back with an "is not a function" error.)
						- (After "const [Mongoose Schema Name] = new mongoose.Schema({ ..." )  // Creating the schema
							- 	"[Mongoose Schema Name].plugin(findOrCreate);"
								- i.e. "user_schema.plugin(findOrCreate);"
					- Setup Oauth access on developer section of third party authorization website
						- i.e. https://console.developers.google.com/
							- Create new project
							- Go to Credentials
							- "Configure Consent Screen"
								- "External" -> Create
								- Fill in page, (i.e. Application name, logo, support email, etc)
								- If you want more than the default email/profile/openid, click "Add Scope" and do whatever's needed to add additionally-requested info
							- Go back to Credentials
								- "Create Credentials" > OAuth client ID
									- Fill in info, especially:
										- "Authorized JavaScript origins," (the page that will be making the request to Google)
										- "Authorized redirect URIs," (the page you want Google to send the user to after authenticating)
									- Will give you "Client ID" and "Client Secret" codes
										- Add to .env file
					- Configure Strategy
						- "const Google_Strategy = require('passport-google-oauth20').Strategy;"
						- (After "passport.deserializeUser([Mongoose Model Name].deserializeUser());")
							- 	"passport.use(new Google_Strategy({
										clientID: process.env.GOOGLE_CLIENT_ID,
										clientSecret: process.env.GOOGLE_CLIENT_SECRET,
										callbackURL: process.env.BASE_URL_DEV + process.env.PORT + '/auth/google/secrets'   // Swap to BASE_URL_PROD when releasing
									}, 
									function(accessToken, refreshToken, profile, cb) {
										User.findOrCreate({ googleId: profile.id }, function (err, user) {
											return cb(err, user);
										});
									}
								));"
					- Authenticate Requests
						- 	"app.get('/auth/google',
								passport.authenticate('google', { scope: ['profile'] })
							);
						-   "app.get([Google Authorized redirect URIs],
						 		// i.e. "app.get('/auth/google/secrets',   
								passport.authenticate('google', { failureRedirect: '/login' }),
								function(req, res) {
									res.redirect('/[Whatever route is for your authenticated users only]');
										// i.e. res.redirect('/secrets');
								}
							);
					- Store Google ID to database to function as an alternate user id for all data created on our site
						- Since the third-party Oauth'd user won't have a local email address to store and use in the future
							- And apparently Google doesn't send in their profile.
						- Add "googleId: String" to schema
	- React, (/JSX)
		- Front-end Framework
			- Combine HTML, CSS and JS into each component
			- Each component listens for and performs its own updates without requiring full page reloads.
		- Installation
			- (There are multiple options here, none of which do a good job of following the normal "npm install [only_the_package(s)_that_I_actually_want]" format, then additions of import/const in [package.json "main" js file], and finally showing you how to setup the required bits so that you actually understand how to use)
				- OPTION 1 - Direct Module Install / HTML embedding
					- This is the closest to normal installation, but is incomplete, as it doesn't include routing or hot reloads
						- I may, at some point, add the additional bits to install and configure here, but unfortunately, it's not a trivial exercise to do it all by hand, so we'll see.
					- In html/ejs file, (in a publicly-accessible directory)
						- "<div id="root"></div>"   // Will be what we update for all React code.
							- id="root" is just a convention, can certainly update other bits of the DOM if you'd rather
						- "<script src="[package.json "main" js file]" type="text/jsx"></script>"
							- (Note: Some people use type="text/babel" instead of "text/jsx")
								- ("text/jsx" just says that the file is jsx and needs a non-specified "transpiler" - i.e. a translator - to convert its contents to regular js)
									- (Through external config files, this transpiler will generally be configured to be Babel - babeljs.io - anyway)
										- (Thus, "text/jsx" and "text/babel" - the latter of which specifically calls the Babel transpiler - end up generally being functionally equivalent)
											- (So, either use "text/jsx" and change the configured transpiler outside of the file, if you want)
												- (Or, just set "text/[direct transpiler name]" - i.e. "text/babel" inside the file, whichever makes you happier)
					- "npm install react react-dom"
					- In [package.json "main" js file]
						- (which, for some reason, wants to be inside a "src" subdirectory in your project directory)
						- "import React from 'react';" OR "const React = require('react');"  // The first way is the newer ES6+ way, but both ways work.
							- (Seems to be a need to capitalize "React", even if doing in the Node.js / const/require way)
						- "import ReactDOM from 'react-dom';" OR "const ReactDOM = require('react-dom');"  // The first way is the newer ES6+ way, but both ways work.
							- (Seems to be a need to capitalize / smush "ReactDOM", even if doing in the Node.js / const/require way)
				- OPTION 2 - Create React App  //  Most common way to begin to learn React
					- (NOTE: WILL NOT WORK ON non-Linux disk partitions - due to React scripts with relative paths to symlinked file locations, this option WILL NOT WORK on an non-Linux disk partition)
						- (Even with the usual "rsync -avL node_modules" workaround)
					- (Takes 5-10+ minutes to install for a single-page only website)
					- From outside of the project directory for [the name of your React application]
						- "npx create-react-app [the name of your React application]"
							- (Will spend literally 5-10+ minutes creating a new project directory named [the name of your React application], installing a whole mess of modules, and filling that project directory with a whole mess of files, several of which you'll probably just delete)
						- "cd [the name of your React application]"
						- "npm start"
							- (Starts app at localhost:3000, and will also automatically open a browser window to that location)
						- In [the name of your React application]/public  // OPTION 1 "In html/ejs file..." equivalent
							- Delete all files
							- Add "index.html" with standard HTML starter tags
								- "<div id="root"></div>"   // Will be what we update for all React code.
									- id="root" is just a convention, can certainly update other bits of the DOM if you'd rather
								- "<script src="[package.json "main" js file]" type="text/jsx"></script>"
									- i.e. "<script src="../src/index.js" type="text/jsx"></script>"
									- (Note: Some people use type="text/babel" instead of "text/jsx")
										- ("text/jsx" just says that the file is jsx and needs a non-specified "transpiler" - i.e. a translator - to convert its contents to regular js)
											- (Through external config files, this transpiler will generally be configured to be Babel - babeljs.io - anyway)
												- (Thus, "text/jsx" and "text/babel" - the latter of which specifically calls the Babel transpiler - end up generally being functionally equivalent)
													- (So, either use "text/jsx" and change the configured transpiler outside of the file, if you want)
														- (Or, just set "text/[direct transpiler name]" - i.e. "text/babel" inside the file, whichever makes you happier)
						- In [the name of your React application]/src
							- Delete all files
							- Add [package.json "main" js file] // i.e. "index.js"
								- "import React from 'react';" OR "const React = require('react');"  // The first way is the newer ES6+ way, but both ways work.
									- (Seems to be a need to capitalize "React", even if doing in the Node.js / const/require way)
								- "import ReactDOM from 'react-dom';" OR "const ReactDOM = require('react-dom');"  // The first way is the newer ES6+ way, but both ways work.
									- (Seems to be a need to capitalize / smush "ReactDOM", even if doing in the Node.js / const/require way)
				- OPTION 3 - Next.js  //  Most common way to build production React applications
					- (NOTE: WILL NOT WORK ON non-Linux disk partitions - due to React scripts with relative paths to symlinked file locations, this option WILL NOT WORK on an non-Linux disk partition)
						- (Even with the usual "rsync -avL node_modules" workaround)
					- (Similar in function to Option 2, but, at least, it's 1-2 mins vs 5-10+, and it's useful for more than a single page website)
					- From outside of the project directory for [the name of your React application]
						- "npx create-next-app [the name of your React application]"
						- "cd [the name of your React application]"
						- "npm run dev"
							- (Starts app at localhost:3000)
						
		- Use
			- In [package.json "main" js file]
				- "ReactDOM.render([single standard html element], [part of the DOM you want to update with React code, expressed in standard javascript]);"
					- [single standard html element] can be a <div>
						- Which is how you send more than a single html tag via react, i.e.
							- 	"ReactDOM.render(
									<div>
										<h1>This is a header</h1>
										<ul>
											<li>Item 1</li>
											<li>Item 2</li>
											<li>Item 3</li>
										</ul>
									</div>,
									document.getElementById('root')  // [part of the DOM you want to update with React code, expressed in standard javascript]
								);"
						- Can also contain javascript expressions (only) inside HTML
							- (Expressions produce a value - i.e. a + b, the Math.floor expression below, etc)
							- By surrounding javascript calls with {}, i.e.:
								- 	"const name = 'Sabrina';"
									"ReactDOM.render(
										<div>
											<h1>Hello {name}!</h1>
											<p>Your lucky number is {Math.floor(Math.random() * 10)}</p>  // Note: don't include ";" between "...10)" and "}"
										</div>,
										document.getElementById('root')
									);"
									- Which renders as
										"<div>
											<h1>Hello Sabrina</h1>
											<p>Your lucky number is [whatever number was generated]</p>
										</div>"
							- Cannot use javascript statements
								- (Statements perform an action - i.e. loops, if...then...else)
			- React-required adjustments to using HTML attributes, (CSS styling, etc)
				- Because the HTML is inside a javascript file instead of an HTML file
					- Instead of "class=" (HTML) you have to use "className=" (javascript)
					- Multi-word HTML attributes, (i.e. "contenteditable", "font-size") need to use camelCase instead, (i.e. "contentEditable", "fontSize")
					- HTML attributes that take multi-word string arguments, (i.e. 'style="color: red; font-size: 30px;"') need to use javascript objects instead, (i.e. "style={{color: "red", fontSize: "30px"}}")
						- Note the double curly braces
							- The outer pair is to signify that you're inserting javascript
							- The inner pair is for opening / closing the javascript object itself
			- Components
				- Way of breaking up page into multiple, independent, sections
				- Place each segment of HTML/JS that you want to turn into a component into a function, with the "return" set to the HTML/JS
					- CRITICAL NOTE: the name of the function HAS TO have the first letter capitalized for this to work
					-	i.e.	"function Heading() {
									return <h1>This is my heading</h1>;
								}"

								"function List() {
									return <ul>
										<li>Item 1</li>
										<li>Item 2</li>
										<li>Item 3</li>
									</ul>;
								}"
				- Replace the appropriate location in the ReactDOM.render HTML with the name of your function, with the first letter capitalized, as an empty, self-closing, HTML tag
					- i.e.	"ReactDOM.render(
								<div>
									<h1>This is my heading</h1>
									<ul>
										<li>Item 1</li>
										<li>Item 2</li>
										<li>Item 3</li>
									</ul>
									<p>Random other paragraph</p>
								</div>,
								document.getElementById('root')
							);"

							with the two above functions, (i.e. "Heading" and "List") becomes

							"ReactDOM.render(
								<div>
									<Heading />
									<List />
									<p>Random other paragraph</p>
								</div>,
								document.getElementById('root')
							);"
				- As with any other javascript functions, can move component functions to an external file to clean up [package.json "main" js file]
					- Create external file - [whatever name you want].js  // Some folks would prefer the file extension be .jsx or .mjs since the file will contain other than standard javascript
					- In [whatever name you want].js
						- Since the components will include React bits
							- "import React from 'react';" OR "const React = require('react');"  // The first way is the newer ES6+ way, but both ways work.
						- Add any function definitions you want, tagging any functions you want to be externally-accessible with the "export" keyword
							- i.e.	"export function Heading() { ...  // "export" keyword included, so Externally-accessible

									export function List() { ...  // "export" keyword included, so Externally-accessible

									function List_Helper() { ..."  // "export" keyword not included, so Not Externally-accessible
						- Define the default function, even if there is only one function in the file
							- i.e. "export default Heading;"
					- In [package.json "main" js file]
						- "import {[array of the functions you want to access, or "* as [Alias]" if you want to access them all]} from "[relative path to "[whatever name you want].js".  File extension does not need to be included, but can be]"
							- i.e. "import { Heading, List } from "./modules";"
								- (If you still have the original functions in [package.json "main" js file], make sure to delete them / comment them out)
									(To avoid an error for having two identically-named functions - one in [package.json "main" js file] and one in [whatever name you want].js)
									- Namespaces
										- For when using "*" instead of named functions
											- If you're importing * from two external module files, (or [package.json "main" js file] and one external file, as above) and both of those module files have functions named "Jump", for example
												- You need to be able to say whether you want to use the Jump function in [File1] or the Jump function in [File2]
													- You can, (and have to) do so by using the "as [Alias]" phrase in the import statement
														- i.e.	"import * as Big from "./[File1].js";"
																"import * as Small from "./[File2].js";"
														- You would then access Jump from [File1] as "Big.Jump()"
															- And Jump from [File2] as "Small.Jump()"
										- For when using named functions instead of "*"
											- Unfortunately, in Javascript, it doesn't quite work the same when asking for specific named functions
												- Instead of being able to use the above "* as [Alias]" syntax
													- (i.e. "import {Jump, Dance} as Big from "./[File1].js";", and then accessing as "Big.Jump()" and "Big.Dance()") as would be expected)
													- The best you can do is pretend-emulate for each named function
														- i.e. 	"import {Jump as BigJump, Dance as BigDance} from "./[File1].js";"
																"import {Jump as SmallJump, Dance as SmallDance} from "./[File2].js";"
																- (Note: You cannot even use "... Jump as Big.Jump ...", as that's an error)
														- You would then have to access Jump from [File1] as "BigJump()"  // No periods
															- And Jump from [File2] as "SmallJump()"  // No periods
				- Props, (/Properties)
					- Used to make React functions, (/ components) modular
						- Can have one "Person" function, (/ component) with the info for multiple people
							- i.e.	"<Person name="Ed" age=12 />
									<Person name="Julia" age=35 />
									<Person name="Herman" age=26 />"
								- Can also externalize values into an array of javascript objects
									- i.e. people = [{"name": "Ed", age: 12}, {"name": "Julia", "age": 35}, {"name": "Herman", "age": 26}]
										- (Can also then move this array into an external file, if you want)
											- (And then re-access by "import"ing the array from the external file)
									- And access as:
										"<Person name={people[0].name} age={people[0].age} />
										<Person name={people[1].name} age={people[1].age} />
										<Person name={people[2].name} age={people[2].age} />"
						- Can use in the function definition by specifying the name for a javascript object taken as an argument
							- Traditionally, the name used is "props", (as in "properties")
							- i.e. function Person(props) { ...
								- Access via props.[attribute name]
									- i.e. "props.name", "props.age"
									- (Surrounded by {}, as needed for javascript bits)
										- i.e.	"function Person(props) {
													return 	<div>
																<h2>{props.name</h2>
																<p>Age: {props.age}</p>
															</div>;
												}"
							- (Note: props are read-only)
						- If passing information from a function in another file
								- Need to pass using an object
									- Can be used bi-directionally
								- (i.e. from calling file/App.jsx to component file/ToDoItem.jsx - i.e. to pass the text for each item in an array)
									- i.e.
										- In App.jsx:
											"import ToDoItem from "./ToDoItem";"

											(...)

											"{items.map((todoItem) => (
												<ToDoItem text={todoItem} />
											))}"
										- In ToDoItem.jsx:
											- 	"function ToDoItem(props) {
													return <li>{props.text}</li>
												}

												export default ToDoItem;"
								- (i.e. from component file/ToDoItem.jsx to calling file/App.jsx - i.e. to delete an item from that array)
										- In App.jsx:
											"import ToDoItem from "./ToDoItem";
											let [items, setItems] = React.useState([]);"

											(...)

											"function delete_item(id) {
    											setItems((prevItems) => {
      												return prevItems.filter((items, index) => {  // Create a new, filtered array with everything from the prior array except for the item we want to delete, then save this array in place of the prior one.
        												return index !== id; 
      												});
    											});
  											}"

											(...)

											"{items.map((todoItem, index) => (
												<ToDoItem
													key={index}
													id={index}
													text={todoItem}
													on_checked={delete_item}
												/>  // Technically, apparently React doesn't like the idea of using an index as a key, since the item being referred to at a given index can be changed, so React prefers you to generate a UUID for each item.  Will leave that up to you to do or not.  Not doing here.
											))}"  // Have to pass all necessary values and function names from the calling file to component file as props
										- In ToDoItem.jsx:
											- 	"function ToDoItem(props) {
													return (
													 	<li
														 	onClick={() => {  // Need to pass as an anonymous function, (vs a standard onClick={props.on_checked}) so that you can pass the value in props.id to the function props.on_checked.  Yes, this is another incidence of what should be entirely unnecessary complexity.
																props.on_checked(props.id); 
															}}
														>
															{props.text}
														</li>
													);
												}

												export default ToDoItem;"
				- .map in React
					- Can be used to create multiple React components from an array of javascript objects with a single command
						- Instead of having to manually create <Person name={people[X].name} age={people[X].age} for all objects in the people array
							- Initial Setup, (/Confirmation)
								- Create (/Confirm that you have) the [Initial Function] to be used, with props
									- i.e.	"function Person(props) {
										JavaScript		return 	<div>
															<h2>{props.name</h2>
															<p>Age: {props.age}</p>
														</div>;
											}"
								- Create (/Confirm that you have) an [Array of Javascript Objects] to be mapped to the [Initial Function]
									- i.e. people = [{"name": "Ed", "age": 12}, {"name": "Julia", "age": 35}, {"name": "Herman", "age": 26}]
										- (If in an external file, make sure you use const and export default)
											- (i.e. 	const people = [
															{
																"name": "Ed",
																"age": 12
															},
															{
																"name": "Julia",
																"age": 35
															},
															{
																"name": "Herman",
																"age": 26
															}
														];
														
														export default people;)
							- Create a [Second, Mapping Function] to define the relations between the values in the [Array of Javascript Objects] and the [Initial Function]
								- i.e.	"function Create_Person(person) {  // Lower-case "person" is just a variable name, could be any string you want
											return <Person key={person.name} name={person.name} age={person.age} />;  // Where "name" and "age" are the object attributes in the array
										}"
									- (Note: React gets ornery, if you don't define a unique key, (with an explicit "key={[some field]}" attribute) before using .map)
										- (Will still function, but will show a warning in React Developer Tools)
											- (If you want to make this warning go away)
												- (You will need to either:  )
													- (Specify one of the extant fields as a key, ("key=") )
														- (If the values in that field are, and should always be, unique)
														- (Note: React explicitly defines this "key=" attribute as NOT a property, (/prop) of the objects in the array)
															- (And thus, does not allow it to be referenced as would otherwise be expected)
																- (i.e. "{person.id}")
																- (So you need to double-declare the attribute, once as "key=" and a second time as "[whatever you would have otherwise named it - i.e. "name" ]=" to be able to access that attribute)
																	- (Using the non-"key=" name to access as a property)
																		- (i.e.	"function Create_Person(person) {  )
																				(	return <Person key={person.name} name={person.name} age={person.age} />;  ) 
																		(		}"
												- (Or:  )
													- (Alter the initial array to ensure it has a unique key field, if it doesn't already have one)
														- (e.g. The previous "people" array:  )
															- ("people = [{"name": "Ed", "age": 12}, {"name": "Julia", "age": 35}, {"name": "Herman", "age": 26}]")
														- (Becomes:  )
															- ("people = [{"id": 1, "name": "Ed", "age": 12}, {"id": 2, "name": "Julia", "age": 35}, {"id": 3, "name": "Herman", "age": 26}]")
													- (And add a "key=" attribute to the Create_Person function definition)
														- (i.e.	"function Create_Person(person) {  )
																(	return <Person key={person.id} name={person.name} age={person.age} />;  )
														(		}"
							- Call the .map function on the [Array of Javascript Objects] wherever you want the instances of the [Initial Function] to appear
								- Pass the [Second, Mapping Function] as the argument to the .map function
									- i.e. 	"{people.map(Create_Person)};"
								- Will create one instance of the [Initial Function], (i.e. "<Person ...") for each object in the [Array of Javascript Objects], (i.e. "people").
								- Could also do as a single statement with Arrow Notation
									- i.e. 	"{people.map(person => (
												<Person
													key={person.name}
													name={person.name}
													age={person.age}
												/>
											))};"
				- Conditional Rendering / Ternary Operators
					- Way of re-writing an if/then/else expression, (which you can't use in React) into a functionally-identical statement, (which you can)
					- "[Logical Condition - i.e. If Portion] ? [Then Portion] : [Else Portion]"
						- Example if/then/else:
							- 	"if (is_logged_in === true) {  // for boolean variables, simply specifying the variable name itself, ( "(is_logged_in)" ) is functionally equivalent to "(is_logged_in === true)"
									return <h1>Hello</h1>;
								} else {
									return <h1>Login</h1>;
								}"
						- Converted to a ternary operator:
							- 	"is_logged_in === true ? <h1>Hello</h1> : <h1>Login</h1>"
								- (Note: Neither the [Then Portion] or [Else Portion] should include the return keyword or the ending ";")
								- (Technically, since a boolean equality can be tested by just calling the variable name, without needing the "=== true")
									- (You could also do the example version as "if (is_logged_in) { ..." and the ternary version as "is_logged_in ? <h1>Hello</h1> : <h1>Login</h1>")
						- If you wish to do nothing for either [Then Portion] or [Else Portion], simply set that portion of the ternary operator to "null"
							- i.e. "is_logged_in === true ? <h1>Hello</h1> : null"
								- (or "is_logged_in ? <h1>Hello</h1> : null")
									- Can actually be simplified even further due to the way Javascript evaluates [Compound Logical Conditions - i.e. If Portion with more than one test]
										- If [Logical Condition - i.e. If Portion] includes a "&&" // an "and"
											- i.e. (is_logged_in && name="Herman") 
											- Since both terms have to be true for the [Compound Logical Conditions - i.e. If Portion with more than one test] to be true
												- Javascript will stop evaluation if the first test - i.e. the one before the "&&" evaluates to false
													- This can be used to modify the [Compound Logical Conditions - i.e. If Portion with more than one test] into becoming the entire ternary operator
														- (Knowing that the right side of the "&&" operator in the [Compound Logical Conditions - i.e. If Portion with more than one test] will only be accessed at all if the left side is true)
														- "[Logical Condition - i.e. If Portion] && [Then Portion]"
															- i.e. "is_logged_in && <h1>Hello</h1>"
																- (Note: In React, if trying to pass boolean values via props)
																	- (i.e. "{props.is_logged_in && <h1>Hello</h1>}" inside "function Greeter(props) { ...")
																		- (You have to enclose the boolean value you're trying to pass in curly braces)
																			- (i.e. "<Greeter is_logged_in={true} />")
				- Hooks
					- Way of using state in React components
						- (state = all attributes of a given item at a given time)
						- (Replaces older class-based method of using state in React)
							- (i.e. "class App extends React.Component { render() { return ...")
								- (with lots of "this.[Whatever]"s)
					- (Note: cannot be used in index.js)
					- React.useState([Array, where Array[0] is a value, and Array[1] is a function])
						- (Note: there are other React hooks beyond just "useState", but that is the one most commonly used)
						- (Note: has to be inside another function, i.e. App() )
						- i.e.	"function App() {	
									let [count, set_count] = React.useState(0);  // Note: uses Destructuring to concurrently assign "count = Array[0]", (which we then assign = 0, by passing as an argument), and "set_count = Array[1]", (which is just a setter function used to change the value of the named variable mapped to the value in Array[0], in this case "count")

									function increase() {
										return set_count(count + 1);  // Note: do not use "count++" instead of "count + 1", as the button will then require two presses each time to increment, (count++) vs the one press intended, (count + 1)
									}

									return (
										<div className="container">
										<h1>{count}</h1>
										<button onClick={increase}>+</button>
										</div>
									);
								}"
						- Can use more complex state definitions by passing an object to React.useState
							- i.e. 	"let [full_name, set_full_name] = React.useState({
										"first_name": "John",
										"middle_name": "Hamish",
										"last_name": "Watson"
									});"
							- However, when attempting to update individual keys, React will null out the value of any non-specified keys
								- So, instead of being able to do a simple "set_full_name({"first_name": "Ed"});" // which will yield {"first_name": "Ed", "middle_name": "", "last_name": ""}, rather than the intended {"first_name": "Ed", "middle_name": "Hamish", "last_name": "Watson"}
									- You need to explicitly define the update function to update all keys that you didn't actually want to update with their prior values, in addition to the updating the keys that you actually really wanted to update with their new values.
										- This is much less onerous than it could be if you use the Spread Operator, ("...", see above)
										- i.e.	"function handle_change(event) {
													event.persist(); // Only required for React < v.17, or React Mobile, (< v.17, React events would null out after the first time they were triggered, so if you tried to, say, type a word into an input string, all event values would be populated properly when the first letter was entered, but then all values for the event would be nulled out as soon as you typed the second letter, unless you explicitly added "event.persist()".  This behavior was done away with on the Web in React v.17, and events now retain their values as expected, so "event.persist()" is no longer required if you are using React 17+.  If you want to know more, see https://reactjs.org/docs/legacy-event-pooling.html).

													if (event.target.name === "fName") {  // <input name="fName" ...
														set_full_name((previous_value) => {      
															return {
																...previous_value,  // Adds a copy of all the keys of previous_value
																"first_name": event.target.value,  // Overwrites the copied values of the previous_value keys you actually wanted to update.
															}
														}); // {"first_name": [Whatever's typed in the "fName" <input> tag], "middle_name": "Hamish", "last_name": "Watson"}
													} else if (event.target.name === "mName") {  // <input name="mName" ...
														set_full_name((previous_value) => {      
															return {
																...previous_value,
																"middle_name": event.target.value
															}
														}); // {"first_name": "John", "middle_name": [Whatever's typed in the "mName" <input> tag], "last_name": "Watson"}
													} else {  // presuming only three <input> tags exist  // <input name=[Whatever other than "fName" or "mName", but logically, would be "lName"]
														set_full_name((previous_value) => {      
															return {
																...previous_value,
																"last_name": event.target.value  // Wanted to update
															}
														});  // {"first_name": "John", "middle_name": "Hamish", "last_name": [Whatever's typed in the third <input> tag]}
													}
												}"
										- OR
											- If you make the key names the same as the names used in the <input> tags
												- i.e. 	"let [full_name, set_full_name] = React.useState({
													"fName": "John",
													"mName": "Hamish",
													"lName": "Watson"
												});"
											- Can get rid of the if statements, and simply sub in the input name variables 
												- i.e.	"function handle_change(event) {
													   		event.persist();

													   		set_full_name((previous_value) => {
												     			return {
												       				...previous_value,
												       				[event.target.name]: event.target.value  // Note [] around the variable name.  If the key names used in this statement are anything other than the variable names defined in the React hook itself, React will not interpret the name used as a variable, but just as a random string UNLESS the name is encased inside "[]", (not "{}" as in most javascript items, but "[]")
												     			};
												   			});
												 		}"
				- Common combination of hooks & ternary operators is to emulate responsiveness by adjusting styling when an action occurs, (i.e. onClick)
					- i.e.
						"function ToDoItem(props) {
  							let [is_done, set_is_done] = React.useState(false);

  							function handle_click() {
    							set_is_done((prevValue) => {
      								return !prevValue;
    							});
  							}

  							return (
    							<li
      								onClick={handle_click}
      								style={{ textDecoration: is_done ? "line-through" : "none" }}
    							>
      								{props.text}
    							</li>
  							);
						}"
					- (Note: the use of the JavaScript "prevValue" event property and "!prevValue", (i.e. "not/opposite of prevValue") is an easy way to specify an item that, for example, can be clicked and unclicked as often as desired)
						- (There's also a prevItems for arrays, and probably other prev[whatevers])
				- Forms
					- Use React state, (vs standard HTML form element state) and events
						- i.e.	"function App() {
									let [name, set_name] = React.useState("");  // Will often see as "const [name, set_name] ..." but since this is expressly being used to define mutable variables, definitely should not be declared as a const
									let [is_clicked, set_is_clicked] = React.useState(false);

									function handle_change(event) {
										set_name(event.target.value);  // or event.target.placeholder or event.target.type, etc.
									}

									function handle_click() {
    									set_is_clicked(true);
  									}

									return {
										<div className="container">
											<h1>Hello {is_clicked ? name : null}</h1>  // Note: do not use curly braces around a React variable inside a React statement, as this passes an object vs a value
											<input
												onChange={handle_change}
												type="text"
												placeholder="What's your name?"
												value={name}  // Converts this HTML form element into a "Controlled Component" - i.e. forces the HTML form element, (i.e. <input>, <textarea>, <select>, etc) to use React state vs their own internal state, which could be different.
											/>
											<button onClick={handle_click}>Submit</button>
										</div>
									}
								}"
						- (Note: The above doesn't use the standard HTML <form> tag)
							- (Since the default behavior of an HTML <form> is to refresh the page on submit)
								- (Which will reset React back to its initial state, which often is not what you want)
							- (If you want to use the <form> tag)
								- (In the function that handles the submit, have to explicitly tell the form not to refresh the page)
									- (i.e.	"function handle_click(event) {  // have to add "event" argument to the function definition
												set_is_clicked(true);
												event.preventDefault();  // Stops page refresh
											}"  )
								- (Move handle_click from the button's onClick event to the form's onSubmit one)
									- (i.e. "<form onSubmit={handle_click} ...")
								- (Add "type='submit'" flag to the submit button)
									- (i.e. "<button type="submit"> ...")
- JavaScript, (cont'd from Web Development section)
	- Resources
		- JavaScript: Understanding the Weird Parts - https://www.udemy.com/course/understand-javascript/learn/lecture/2237442?start=150#content
	- Hoisting
		- Can access functions and variable names, (though all variable values are set to undefined) earlier in the code than they are actually declared
			- Would be an error in other programming languages
				- (Note: trying to access variable names that are not at all in the file will still show as an error)
		- Happens because the creation of the Global Execution Context, (i.e. the environment in the computer in which your code will be run) is actually created in two parts:
			- Creation Phase
				- Js syntax parser scans entire file and sets up memory space for all variables and functions listed in the file
					- Note: functions written as function statements, (i.e. functions that do NOT return a value) do get hoisted
						- So these type of functions are available before the function declarations
						- i.e. 	greet();   // Yields "Hi" in the console.

								function greet() {  // Function Statement, (does NOT return a value) so is hoisted
									console.log("Hi");
								}
					- However, if you write functions as function expressions, (i.e. functions that do return a value) these are really just variables, so do NOT get hoisted
						- And are thus not available before the function declarations
						- i.e. 	anonymousGreet();  // Yields "undefined is not a function" in the console

								let anonymousGreet = function() {  // Function Expression, (does return a value - i.e. the object) so is NOT hoisted
									console.log("Hi");
								}
			- Execution Phase
				- JS uses single-threaded, synchronous, execution
					- Executes js code, line-by-line, starting from the top
						- Adds new function-specific Execution Contexts to the Stack, above the Global Execution Context, as each function is called
							- With all of the elements of any other Execution Context
								- Including its own specific "this" object, variable environment (i.e. memory location where variables are stored), etc
							- Any other code is paused until the current function's Execution Context completes
								- JS then removes, (/pops) the function-specific Execution Context from the Stack and continues single-threaded, synchronous execution of the code in the current file
									- (Note: multiple function-specific Execution Contexts can be added to the Stack if the called function calls other functions during its execution)
										- (these multiple function-specific Execution Contexts will be executed in a LIFO mode)
											- (LIFO = Last In, First Out)
												- (The last Execution Context added to the Stack is executed until it finishes, at which point it's popped off the Stack and is gone)
													- (Then the second-to-last Execution Context added to the Stack is executed until it finishes, at which point it's popped off the Stack and is gone)
														- (Until all function-specific Execution Contexts have been popped off the stack and we're back in the Global Execution Context)
															- (At which point, execution continues to the next line of code in the file, in a single-threaded, synchronous fashion)
		- (Note: for good coding, don't rely on this)
			- (Declare your functions first, then invoke them, as you would in any other language)
				- (And take hoisting as just a random weirdness of JS)
					- (Not as something for your code to actually depend on)
	- Scope Chain
		- JS uses where you type your code to determine where the (parent/) Outer Context, (/"Outer Lexical Environment") is for any variable at any point in your code
			- (i.e. inside functions, in the Global Context Environment, etc)
			- This is different than where the variable exists on the execution stack
				- The Stack is 1-dimensional
				- The Outer Context, (/"Outer Lexical Environment") is tree-based
					- Where the tree starts at the code file's left margin, (the Global Execution Context)
						- And moves to the right margin only via function definitions inside other function definitions
					- i.e.	function b() {
								console.log(myVar);
							}

							function a() {
								var myVar = 2;
								b();
							}

							var myVar = 1;
							a();
						- The Outer Context tree created is
							- Level 1, (Parent of Level 2): Global Execution Context, (always the first parent)
								- Level 2, (Child of Level 1): function b()
									- The b() function definition is right on the left margin, (the Global Execution Context)
										- So it will always be a direct child only of the Global Execution Context
											- Regardless of wherever it's called, and thus, exists on the Stack.
											- Thus, b()'s Outer Context is only its parent, the Level 1 Global Execution Context
												- Since the Level 1 Global Execution Context has no parents
								- Level 2, (Child of Level 1): function a()
									- The a() function definition is right on the left margin, (the Global Execution Context)
										- So it will always be a direct child only of the Global Execution Context
											- Regardless of wherever it's called, and thus, exists on the Stack.
											- Thus, a()'s Outer Context is only its parent, the Level 1 Global Execution Context
												- Since the Level 1 Global Execution Context has no parents
							- so, if JS couldn't find a given variable, (in this case, "myVar") in either Level 2 function, it would only look to the Level 1 (parent)
								- i.e. the Global Execution Context
									- And "console.log(myVar)" in b() would equal 1, its value in b()'s Level 1 parent.
						- Even though the Stack would be
							- b()   	// Level 2, with the Level 1 being its only parent / only other item in its Outer Context
							- a()		// Level 2, with the Level 1 being its only parent / only other item in its Outer Context
							- Global	// Always the Level 1
					- If we modified the code to move b()'s function definition to inside a()'s function definition:
						- i.e. we created a function definition one block to the right from the left margin, (/ Global Execution Context)
							- 	function a() {
									var myVar = 2;
									function b() {
										console.log(myVar);
									}
									b();
								}

								var myVar = 1;
								a();
							- The Outer Context tree created is
								- Level 1, (Parent of Level 2): Global Execution Context, (always the first parent)
									- Level 2, (Child of Level 1, Parent of Level 3): function a()
										- Since function a() is still defined on the left margin, it still has the Global Execution Context as its only parent
										- Level 3, (Child of Level 2): function b()
											- Since function b() is now defined inside a()
												- And thus one indent to the right of the left margin
												- It is no longer a direct child of the Global Execution Context
													- so, if JS couldn't find a given variable, (in this case, "myVar") in this Level 3 function definition,
														- It would first look for the variable in its parent Level 2 function definition, (i.e. a() )
															- And since a() defines myVar as 2:
																- "console.log(myVar)" in b() would equal 2
															- (Note: if, and only if, a() hadn't had a definition for myVar, JS would then move up the tree one more notch to a()'s parent, the Level 1 Global Execution Context)
																(and "console.log(myVar)" would equal 1
							- Even though the Stack wouldn't have changed, and would still be
								- b()		// Now a Level 3, with a Level 2 parent, so both its Level 2 parent and that Level 2's Level 1 parent would be in its Outer Context, in that order
								- a()		// Still a Level 2, with the Level 1 being its only parent / only other item in its Outer Context
								- Global	// Always the Level 1
	- "Asynchronous" Execution, (/ Callbacks)
		- Since the js engine itself, (i.e. the (Execution) Stack) is single-threaded and synchronous
		- Event Queue
			- Similar to, but independent from, the (Execution) Stack
			- Where the browser, (or Node) adds events, as they occur, (in order of occurrence)
				- i.e. click events, HTTP requests, etc
		- Event Loop
			- Once JS has emptied its current (Execution) Stack, (LIFO)
				- (Last In, First Out)
				- Checks what's on the Event Queue for JS functions to be executed as a result of each event
					- One item at a time, (FIFO)
						- (First In, First Out)
						- If no JS function, pops the event from the Event Queue and moves to the next one
						- If there is a JS function associated with the event, processes on the Stack as usual
							- (i.e. single-threaded, synchronous, LIFO)
							- Once the (Execution) Stack for that function is complete
								- JS again looks to the Event Queue for the next event to process
		- Not really asynchronous, it's synchronous with two queues that it goes back and forth between
			- As individual items complete
				- So, event-based execution will still be blocked until the last event-based execution is completed.
	- Operators
		- Order of Operations
			- Operator Precedence
				- PEMDAS+, (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table)
					- (Precedence goes from highest number to lowest in the table)
			- Operator Associativity
				- When operators have the same precedence
					- Determines whether they should be evaluated Left-to-Right or Right-to-Left
						- For normal math, makes no difference, (i.e. PEMDAS)
							- But does for other operators in the table, including "=", which is used for assignment, not equality
								- i.e. 	let a = 2, b = 3, c = 4;

										a = b = c;

										console.log(a);
										console.log(b);
										console.log(c);
								- All identical operators, and thus identical precedence
									- But Assignment is Right-to-Left associative, (see table)
										- So we start from the rightmost value in the line, (i.e. c)
											- Assign the value in c, (i.e. 4) to b, (which changes from 3 to 4)
											- Then assign the value of b and c, (which are now both equal to 4) to a, (which changes from 2 to 4)
											- So the final state is that all three variables now equal 4.
												- (If assignment has instead been left-to-right associative)
													- (We would have started with the value of a - i.e. 2, and then pushed that value to b and then to c)
														- (Which would have created a final state where all three variables were equal to 2)
			- (Note: since all operators are functions in JS, they have return values that are the result of the operation)
				(i.e. in the "a = b = c;" example above)
					(When b is first assigned the value of c, the "=" operator has a return value of 4)
		- Coercion
			- Implicit
				- When a given operator is defined as having more than one way of operating
					- Dependent on the type of values submitted to it
						- i.e. "+"
							- For Number type values, performs addition
							- For String type values, performs concatenation
								- (i.e. just pushing the two strings together)
				- And values of differently-operating types are submitted to it
					- (i.e. where each type has a defined operation)
					- i.e. 	let a = 1 + '2';	
				- JS will try to pretend that both arguments are of the same Type
					- And will thus use that way of operating
						- i.e. 	In the case of let a = 1 + '2';
							- (i.e. trying to combine a Number type with a String type)
								- (where both types have valid definitions for that operator)
							- JS will "pretend" that the type of one of the arguments is the same as the other
								- And will then use that operator definition to evaluate the line
									- (In this case, JS will pretend that the Number 1 is, instead, the String '1')
										- (and will thus concatenate '1' and '2')
											- (Returning the String '12')
				- (Note: This is a truly fabulous way of creating unintended bugs)
					- (Especially since JS' rules as to how it chooses to implicitly coerce types are obtuse, at best)
						- (https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/)
					- (So, if you really have to combine values of different types in any way)
						- (Use Explicit Coercion / Type Casting, below)
							- (Either temporarily, for a given function only)
								- (i.e. let a = 1 + Number('2');
							- (Or, much better, to formally alter / create variables with the desired type)
								- (i.e.  let b = Number('2'); )
							- (And then operate as originally intended, using the correctly-typed version of the variable)
								- (i.e.  let a = 1 + b; )
									- (Which will always return the Number 3)
				- (Note: If, when evaluating equality/inequality)
					- (You use the strict equality/inequality operators - "===" / "!==")
						- (Instead of the loose equality/inequality operators - "==" / "!=")
							- (JS will not use implicit coercion)
								- (Which is a good thing, so use "===" / "!==")
			- Explicit, (/ Type Casting)
				- Using keywords to actively alter what type a given value returns
					- i.e.	let a = 1 + number('2');
						- Forces JS to evaluate the String '2' as the Number 2
							- Returning the Number 3
								- (Rather than using its implicit preference, shown above)
									- (i.e. to evaluate the Number 1 as the String '1')
										- (And thus to return the String '12')
					- Note: this doesn't actually change the type of the value in question
						- (i.e. The type of '2', or any such variable with a type of String remains String)
							- (All you're doing by virtue of number('2') or number([other variable with a type of String])  )
								- (Is telling JS that for purposes of whatever operation you're trying on that String)
									- (in this case, "+" )
										- ("pretend" that the value is of the type you specifically set, in this case, Number)
											- (And then evaluate the line while it "pretends" what you told it to)
		- Comparison Operators
			- Since JS implicitly coerces values whenever it receives a type it wasn't expecting
				- You can often end up with comparisons returning logically incorrect results
					- i.e. 	console.log(1 < 2 < 3);
						- Logically, that is true, so would expect it to return a Boolean true
							- Which it does
					- However, console.log(3 < 2 < 1);
						- Is logically false, so would expect it to return a Boolean false
							- Unfortunately, it returns a Boolean true, due to coercion
								- i.e. Since the "<" operator is left associative
									- JS first evaluates "3 < 2" which is false
										- Then it subs that false in for "3 < 2"
											- Next evaluating "false < 1"
												- Since its now trying to compare a Boolean with a Number
													- It coerces the Boolean false into Number(false)
														- Which is 0
															- So then evaluates
																- "0 < 1" which is true, so it returns Boolean true
																	- Even though, logically, every element of the original statement, (i.e. "3 < 2 < 1") is false
					- Now that we've looked at the trainwreck of why "3 < 2 < 1" is, in JS' mind, true
						- Looking back at "1 < 2 < 3"
							- JS is evaluating "1 < 2" which is true, returns Boolean true
								- Next it evaluates "Number(true) < 3"
									- Number(true) = 1
										- So it evaluates is "1 < 3" which is true, returns Boolean true
							- We can see that "1 < 2 < 3" has the same programmatic problems as "3 < 2 < 1"
								- With trying to compare arguments of different types and thus using implicit coercion
									- And that the way that it's solving the problem is still, logically, entirely incorrect
										- It just happens to be that JS' incorrect processing arrives at same answer as correct logical processing would give
			- To avoid this chaos
				- Avoid using more than one comparison operator in the same statement
				- Use explicit coercion / type casting anywhere the type(s) of arguments passed to your function haven't been programmatically guaranteed
					- Always safest just to explicitly coerce
					- And make sure that the explicit coercion you're using actually yields the result you're expecting
						- Since
							- 		Number(undefined) = NaN  // "Not a Number"
							- but 	Number(null) = 0
						- And
							- "null == 0" and "null === 0" are both false
							- While the explicitly coerced versions of those statements
								- "Number(null) == 0" and "Number(null) === 0" both evaluate to true
	- Objects and Functions
		- Can contain
			- Primitives - i.e. "person.firstName"
			- Other Objects - i.e. "person.address"
				- Where person.address has been created as an object that exists inside the person object
			- Methods - i.e. functions / "person.create"
				- Where person.create has been created as a function that exists inside the person object
			- (In the computer's memory)
				- (An object is an area in memory - i.e. 0x001)
					- (That contains references to other areas in memory for each of the above, when defined)
						(i.e. Primitives - i.e. 0x002, Other Objects - i.e. 0x003, and Methods - 0x004)
							- (Note: Each Primitive / Other Object / Method, once defined, will have its own memory location)
		- Created by:
			- let [object_name] = new Object();
			- let [object_name] = {};  // Called an Object Literal
				- (Preferred way of creating an object)
				- Can define properties, (and, as with functions) with default values, as part of the object definition
					- i.e. 	let person = { 
								firstName: "John",
								lastName: "Smith",
								address: {
									street: "123 Main St",
									city: "Anycity",
									state: 'CA'
								}
							};
						- Which can then be accessed as person.firstName, person.lastName, or person.address.street
							- (Or person['firstName'], person['lastName'] or person['address']['street'])
								- (Though using dot notation - i.e. person.firstName - is preferred)
				- Can use Object Literal to define a new object during a function call
					- i.e. 	Directly below the person object definition below, we define a function to make use of that object
						- 	function greet(person) {
								console.log("Hi " + person.firstName);  // Outputs "Hi John", using default values
							}
						- And can then pass an object, using an object literal 
							- i.e.	greet({
										firstName: "Mary",
										lastName: "Doe"
									});  // Outputs "Hi Mary", since a new object, with a new firstName and lastName, was created the moment the function call was made
		- Object Literals vs JSON, (_J_ava_S_cript _O_bject _N_otation)
			- JSON is a subset of valid object literal syntax
				- JSON: Property names need to be inside quotes
					- Object Literal property names _can be_ inside quotes
						- But there is no requirement for them to be so
			- Conversions
				- Object literal to JSON --> JSON.stringify([object literal]);
				- JSON to object literal --> JSON.parse([json string]);
		- Functions
			- JS functions are:
				- Just a (special) type of object
					- So, just as with any other object, can attach:
						- Primitives
						- Other Objects
						- Methods
					- Also has:
						- A Name property
							- Optional, can be anonymous
						- A Code property
							- (Which is invocable / callable)
								- (When you add parentheses to the name property)
							- Which contains the code of the function
								- (Note: the code of the function is not actually the function itself)
									- (The code is just a property of the function object)
				- First Class Functions
					- Can assign to variables
					- Pass around as arguments
					- Create on the fly

								




- Algorithms and Data Structures
	- Resources
		- The Coding Interview Bootcamp: Algorithms + Data Structures - https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/learn/lecture/8534250?start=0#content
	