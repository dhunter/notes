- Web Design
	- Credits
		- The Complete 2020 Web Development Bootcamp, (https://www.udemy.com/course/the-complete-web-development-bootcamp/)
			- Course Resources List
				- https://www.appbrewery.co/p/web-development-course-resources/
	- CSS elements with multiple measurements on one line
		- The numbers start on the top and go clockwise around the item	
		- {border: 0px 10px 20px 30px;} would have a:
			- 0px border on top
				- (0 doesn't require a measurement type, but can still use)
			- 10px border on the right side
			- 20px border on the bottom
			- 30px border on the left side
		- Shorthand options
			- {border: 0px 10px 20px;}
				- 0px on top
				- 10px on left and right
				- 20px on bottom
			- {border: 0px 10px;}
				- 0px border on top and bottom
				- 10px border on left and right
			- {border: 0px;}
				- 0px border on all four sides
	- Displaying Elements
		- display: block --> nothing else on the same line, but can set width/height
		- display: inline --> anything can appear on same line, but can't set width/height
		- display: inline-block --> combination of prior two
			- Can appear on same line and also can set width/height
		- Hiding Elements
			- (for quizzes, etc)
			- display: none --> removes both the element and its position in the document
				- As if you just deleted the element entirely in the page source
			- visibility: hidden --> removes the element, but keeps its position
				- i.e. you'll see a hole where the element should have been displayed
	- Positioning
		- float: [left/right/etc]
			- Text that was below will now surround the targeted tag
		- position: static - (default) - positioned according to the normal flow of document
		- position: relative
			- Setting top, right, bottom or left properties will move the item relative to its normal, (position: static) position
		- position: fixed
			- Holds position relative to viewport
			- Does not move with scrolling
			- (Can use for menu bar, etc)
		- position: absolute
			- Setting top, right, bottom or left properties will move the item relative to its parent element's position, (including <body>, if no other parents)
			- Moves with scrolling.
		- position: sticky
			- position: relative until it's original position is reached in the document, then swaps to position: fixed
			- (A somewhat more elegant menu bar, etc, if {top: 0;})
		- z-index
			- Only works on items where all items in question have position <> static
				- (Items to go behind need position: absolute/fixed/sticky)
			- Determines 3D display order, (default: 0)
			- Lower values appear behind higher ones
				- If z-indexes are equal, items coming first in the html code will be displayed behind items that come after
					- i.e. if you have 3 divs with equal z-indexes, listed one after another in an html file:
						- Div 1 will be displayed at the back
						- Div 2 will be displayed in the middle
						- Div 3 will be displayed in the front
		- Keeping footer at the bottom of the page without always being displayed
			- In css file
				- html {
					  min-height: 100%;
					  position: relative;
				  }

				  body {
					  margin-bottom: [height of footer];
				  }

				  [footer class/id/however else you access it] {
					  bottom: 0;
					  height: [height of footer];
					  position: absolute;
					  width: 100%
				  }
	- Fonts
		- Embedding
			- In header:
				- <link href="https://fonts.googleapis.com/css?=family[name of family1]|[name of family2]|[name of family3]" rel="stylesheet">
		- Sizing
			- 16px, (fixed size) = 100%, (scaling) = 1em, (scaling) = 1rem, (scaling)
				- To convert fixed font size to scaling, divide by 16 = Xem/Xrem
			- Note: scaling inherits from all parent elements
				- So, if <body> is 2em and <h1> is 3em, final size = 6em
				- Unless you use "rem," which ignores all parent settings
					- So, in above, if <h1> is 3rem, (instead of 3em), final size = 3em
	- Designer vs Non-Designer Thinking
		- https://www.udemy.com/course/the-complete-web-development-bootcamp/learn/lecture/12399734#content
		- Color Theory
			- Different shades have different "moods"
				- i.e. Elicit different reactions in people seeing them
					- Many of those reactions are common
				- Good exercise is to analyze (especially print) ads to see how they use color to evoke desired reactions
			- Red
				- Love, Energy, Intensity
				- Generates excitement
			- Yellow
				- Joy, Intellect, Attention
				- Too much yellow can generate attention fatigue
			- Green
				- Freshness, Safety, Growth
				- (Often used for food ads)
			- Blue
				- Stability, Trust, Serenity
				- (medical/medicine/health)
			- Purple
				- Royalty, Wealth, Femininity
			- Combining Colors to make Color Palettes
				- Analogous Colors, (2 colors)
					- Selecting adjacent colors on the color wheel
					- Harmonious, Easy to look at for long periods.
					- Good for primary interface
				- Complimentary Colors, (2 colors)
					- Selecting diametrically-opposed colors on the color wheel
					- Attention-grabbing, but hard to look at for long periods.
					- Bad choice for primary interface.
				- Split Colors, (3 colors)
					- Way of toning down disharmony of Complimentary
					- Instead of picking complimentary color, instead the pick two colors surrounding the complimentary color.
					- Still attention-grabbing, but not as clashy
				- Triadic Colors, (3 colors)
					- Selecting 3 colors equidistant around color wheel
				- Monochromatic, (2 colors)
					- Adding darker or lighter second color in the same family
		- Typography
			- 2 different fonts are good, 3 is pushing it, 4+ is bad
			- Keep moods and time eras consistent
				- i.e. Don't mix Roaring 20's-ish font with Renaissance-ish font
			- Contrast serif-ness, (serif vs sans-serif) and font weights
		- UI Design
			- Function comes before form in all cases
			- Ingrained visual impulses
				- Eyes automatically go to biggest, boldest, brightest thing first
				- Then round things
				- Then smaller things
				- Then lighter-shaded things
			- Think of application as a journey
				- Title > Sub-title > Larger images > Smaller images > Some text
			- Minimize number of alignment lines, (horizontal & vertical)
				- More alignment lines are perceived as "messy"
			- Should work to provide conscious and subconscious queues
				- Use 3D lighting effects to make elements seem more like real world
					- Light should always come from above			
					- i.e. To improve clickthrough on clickable button
						- Unpressed state - slight shadow on bottom
						- Pressed state - no shadow
			- Start in monochrome
				- Focus on spacing / positioning, etc
				- To avoid getting distracted by colors
				- Then add a single pop of color
					- And build up color from there
			- Make sure text over images stands out / is easily readable
				- Especially where image will change
					- If image will always be static, can just mod text color
					- Make sure and test in front of a whole slew of images
				- Colored overlay above image
					- Can look a bit ugly
						- Reducing opacity can help
							- Gaussian blur has similar effect
	- Responsive Design
		- Page design changes based on viewport / screen size used, (i.e. laptop vs ipad vs phone)
			- Bootstrap, (https://getbootstrap.com/)
				- There are other front-end frameworks that perform similar tasks
					- (Bootstrap provides additional CSS functionality beyond just responsive design)
				- Navbar, (requires Javascript)
					- Navbar expands / contracts into hamburger menu
				- Grid System
					- Horizontal content broken into 12ths
						- i.e. to display 4 items per line for laptops, 3 per line for ipads and 2 per line for phones
							- Define outer div set to class="row"
								- Actual content class="[below code]"
									- col-xl-3 - 4 items per line, (12/3) for full screen desktops, (xl)
									- col-lg-4 - 3 items per line, (12/4) for full screen laptops, (lg) presuming resolution is less than desktops
									- col-md-6 - 2 items per line, (12/6) for ipads / windowed content, (md) on desktops/laptops
									- col-sm-12 - 1 item per line, (12/12) for phones, (sm)
									- Note: content class has to include space-separated codes for all scenarios desired
										- i.e. to be fully responsive, class="col-xl-3 col-lg-4 col-md-6 col-sm12"
											- If fewer scenarios specified, will only change display where specified
												- i.e. if only use "col-md-6" by itself, every viewport from medium up in size, (md, lg, xl) will show 2 per line, and below medium, (sm) will show 1 per line.
			- Media Queries
				- Choose different css selectors based on:
					- Media types, (print, screen, speech) and/or
					- Media features, (height, width, orientation, resolution)
				- Very useful for fine-tuning individual bits of design
					- i.e. use Bootstrap for broad-brush design bits
						- Then add in media queries, where desired, to finish off
				- Encase css selectors within query specifying situation they should apply to
					- i.e. @media screen (min-width: 900px) { [css selectors] }
				- If you model css selector classes identically - i.e.:
					- @media screen (min-width: 600px) {
  					  /* For tablets: */
					  .col-s-1 {width: 8.33%;}
					  .col-s-2 {width: 16.66%;}
					  .col-s-3 {width: 25%;}
					  ...
					  .col-s-12 {width: 100%;}
					  }
					 
					  @media screen (min-width: 768px) {
					  /* For desktop: */
					  .col-1 {width: 8.33%;}
					  .col-2 {width: 16.66%;}
					  .col-3 {width: 25%;}
					  ...
					  .col-12 {width: 100%;}
					  }
					
					- You can then call them exactly as with Bootstrap in html - i.e.:
						- <div class="row">
							<div class="col-3 col-s-3">...</div>
							<div class="col-6 col-s-9">...</div>
							<div class="col-3 col-s-12">...</div>
						- </div>
				- Note: css selectors inside media queries override css selectors outside - i.e.:
					- h1 {color: red;}
					- @media screen (min-width: 900) {h1 {color: blue;}}
					- If width < 900, h1's will be red.
					- If width >= 900, h1's will be blue.
	- Accessibility
		- aria-hidden="true"
			- Hides content from assistive technology, (i.e. screen reader) for this and all children elements
				- (for use with buttons, etc)
	- Javascript, (JS)
		- Good source for idiomatic js code -> https://github.com/rwaldron/idiomatic.js/
		- Document Object Model, (DOM)
			- Tree diagram of html code
			- Selecting items, (most common method)
				- document.querySelector("[element]") -> Individual Item
					- If multiples, will only return first one found
				- document.querySelectorAll("[element]") -> Array of all matching
				- [element] uses exact same selectors as CSS
					- i.e. "h1", "p.[class name]", "li a"
			- Modifying items
				- (Uses same properties as CSS, but camelCased instead of hyphenated)
					- (i.e. instead of "font-size," (CSS) it would be "fontSize," (JS))
				- For styles, best is to use ".classList.toggle[[class name]];"
					- (or ".classList.add[[class name]];"/".classList.remove[[class name]];")
					- Toggles adding/removing class selectors that exist in CSS file to items
						- (akin to how Bootstrap works)
							- i.e. add/remove a class of "invisible" or "big" or whatever
					- Lets you keep all styling in CSS file and only use JS for behavior.
				- For actual attributes, (i.e. "href=" in an anchor tag):
					- .getAttribute([attribute name])
					- .setAttribute([attribute name], [new value])
		- Event Listeners
			- When using a named function as the callback function of an event listener
				- (i.e. the function that's supposed to be called once the specified event is detected)
				- Use the function name without parenthesis, or the event will trigger on page load, rather than only when the specified event occurs, i.e.:
					- ".addEventListener('click', handle_click());" -> Triggers on page load, rather than on click, as intended.
					- ".addEventListener('click', handle_click);" -> Triggers on click, as intended.
				- Thus, if you want to actually send back the event object that triggered the callback, you have to use an anonymous, (i.e. not named) function.
					- i.e. ".addEventListener("keydown", function(event) {}"
						- Since you can't do ".addEventListener("keydown", handle_click(event));"
							- And still have it respond only to the event and not page load.
		- Constructor Functions
			- First letter of the function name has to be capitalized, i.e.
				- function Person ([name], [age], [height],...) {
				 	this.name = name;
				 	this.age = age;
				 	this.height = height;
				 	...
				  }
			- When using, have to use "new" keyword before any values passed, i.e.
				- person_1 = new Person ([name_1], [age_1], [height_1],...);
				- person_2 = new Person ([name_2], [age_2], [height_2],...);
			- To add methods, use anonymous functions, (i.e. functions without names)
				- i.e. in above Person definition, add:
					- this.[method_name] = function() {[function definition]}
				- To use for person_1, would just be "person_1.[method_name]()"
		- Javascript Quirks
			- Scope
				- Javascript has 3 concepts of scope for 3 types of assignments:
					- Normal types
						- Global Scope, (available everywhere)
							- var x   -> global
							- let x   -> global
							- const x -> global
						- Block-level Scope, (available only inside a function)
							- NOTE: in Javascript, this is literally only inside a code block defined by the "function" keyword
							- var x   -> local
							- let x   -> local
							- const x -> local
					- Unusual type
						- Inside any other code block not defined by the "function" keyword
							- (i.e. if/else, for, do/while, etc)
							- var x   -> global
							- let x   -> local
							- const x -> local
				- For maximum similarity to other languages, always use "let" instead of "var"
					- ("let" was specifically added to the language in ECMAScript 6 to address this issue)
			- Constants that aren't real constants, (i.e. that aren't immutable)
				- const [array name]
					- You can't reassign [array name] entirely, (which is good)
						- But you can still push items into it, (which is bad)
				- const [object name] = {[key], [value]}
					- You can't reassign [object name] entirely, (which is good)
					- You can't overwrite the name of [key], (which is good)
						- But you can change [value] of [key], (which is bad)
					- You can actually make [object name] immutable after the const assignment
						- By adding Object.freeze([object name])
				- For maximum similarity to other languages, don't use "const" keyword if the array or object isn't really immutable
		- jQuery
			- (Loaded via hosted library, akin to Bootstrap)
				- (i.e. <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>)
			- Simplification of pure javascript
				- "$" at the beginning of a statement signifies you're using jQuery
					- Can also embed jQuery inside javascript on the same line
						- i.e. "console.log($([element]).hasClass([class name]));"
			- Selecting items
				- "$("[element]")
					- Instead of document.querySelector("[element]")
				- No difference between selecting one, (.querySelector) or many, (.querySelectorAll) items
			- Modifying items
				- i.e. ".toggleClass('[class name]');"
					- Instead of ".classList.toggle[[class name]];"
				- Any modifications will apply to every matching item, (whether singular or in an array)
			- Adding/Removing html elements, (without altering actual html files)
				- Adding
					- Around the [element]:
						- Add [html code] immediately BEFORE [element]'s OPENING tag.
							- "$("[element]").before("[html code]");"
						- Add [html code] immediately AFTER [element]'s CLOSING tag.						
							- "$("[element]").after("[html code]");"
					- Inside of the [element]:
						- Add [html code] immediately AFTER [element]'s OPENING tag.
							- "$("[element]").prepend("[html code]");"
						- Add [html code] immediately BEFORE [element]'s CLOSING tag.							
							- "$("[element]").append("[html code]");"
					- i.e. BEFORE <h1> PREPEND [prior h1 content] APPEND </h1> AFTER
				- Removing - "$("[element]").remove();"
		- Node / Node.js
			- Allows Javascript to run outside of the browser
			- To choose version of node to run, install "n" package globally
				- "sudo npm install -g n"
				- To use latest version
					- "sudo n latest"
				- To use LTS, (Long Term Support) version
					- "sudo n lts"
			- For each new project
				- Initialize -> "npm init"
					- (inside project directory)
					- Text-based setup wizard
						- (can also type "npm init -y" to accept all wizard defaults)
						- Will create [package.json] file with results
							- For "dependencies" item:
								- Semantic Versioning
									- [Major Release Version].[Minor Release Version].[Patch Version]
										- i.e. 3.2.5
									- Bug fixes that don't break any functionality increment [Patch Version]
										- i.e. 3.2.6
									- Feature additions that don't break functionality increment [Minor Release Version]
										- i.e. 3.3.0
									- Functionality-breaking additions/subtractions increment [Major Release Version]
										- i.e. 4.0.0
								- When specifying dependency versions, three options:
									- Precise version only -> "3.2.5"
									- Precise version + [Patch Version] -> "~3.2.5"
									- Precise version + [Minor Release Version] -> "^3.2.5"
				- Install any modules needed
					- "npm install [module_name_1] [module_name_2] [module_name_3] ..."
						- To install an older version of any module
							- "npm install [module_name]@[version number]"
				- Startup -> "node [package.json "main" js file]"
					- If code inside [package.json "main" js file] would start a webserver:
						- Requires manually stopping and restarting the server for each saved change in [package.json "main" js file]
						- Nodemon
							- Drop-in webserver replacement for basic "node [package.json "main" js file]"
								- "nodemon [package.json "main" js file]"
									- (To install -> "npm install -g nodemon")
							- Automatically stops and restarts server with every saved change in [package.json "main" js file]
			- Express
				- Node framework analogous to jQuery for Javascript
				- Issues @ 2020-05-22
					- Express uses symlinks when installing, which will not work on FAT32/NTFS volumes
						- (FAT32/NTFS volumes don't allow creation of Linux symlinks)
					- npm has a --no-bin-links flag which should deal with this, but the flag doesn't work
						- (Hasn't worked since at least 2014...  :/ )
					- Workaround
						- Create [twin project directory] on a drive that does create proper symlinks, (i.e. ext4, zfs)
						- Install Express, (and every other non-global module you need for that project) in [twin project directory]. 
						- Delete any prior /node_modules/ directory in [FAT32 project directory]
						- Use rsync to create a copy in [FAT32 project directory], converting symlinks to normal files/directories.
							- "rsync -avL ./node_modules [FAT32 project directory]"
						- cp [twin project directory]/package.json and [twin project directory]/package-lock.json to [FAT32 project directory]
				- Enabling, (add below inside [package.json "main" js file]):
					- const express = require("express");
					  const app = express();
					- Enable static file, (i.e. css, images, etc) access from the outside world
						- In [project directory]
							- "mkdir public"
							- Move all css, image and other static files into [project directory]/public
						- In [package.json "main" js file]
							- "app.use(express.static('public'));"
								- Note: for html link purposes, this will make [project directory]/public considered to be in the same directory as .html(/.ejs) files being rendered
									- i.e. If styles.css actually exists at [project directory]/public/css/styles.css and
										- index.html actually exists at [project directory]
										- After adding the express.static setting, the css link inside index.html:
											- SHOULD BE: "<link rel="stylesheet" href="css/styles.css">"
												- (as if the css subdirectory was directly in [project directory], even though it's not)
											- NOT: "<link rel="stylesheet" href="/public/css/styles.css">"
												- (which is where the file actually is)
					- app.listen([port number]) sets port server will respond on
					- Add routes, (/url permutations) that you want to respond to
						- (if files) app.[HTTP method]([route], function(request, response) {
							response.sendFile(__dirname + "/[relative path to file to send]");
						}) OR (if text) app.[HTTP method]([route], function(request, response) {
							response.send("[random text]");
							- (__dirname is a special Node variable equal to the absolute directory of the current working directory)
							- Where [HTTP method] = "post", "get", "put" or "delete"
								- (corresponding to "create", "read", "update" and "delete" operations)
								- i.e. (if files) app.get("/", function(request, response) {
									response.sendFile(__dirname + "/index.html");
								  }) OR (if text) app.get("/", function(request, response) {
									response.send("Hello World");
							- [route] examples:
								- "/" - home route
									- i.e. responds to the base url of your website
								- "/contact" -> [base url]/contact
								- "/about" -> [base url]/about
							- Chaining Route Handlers
								- Where the route is identical, (i.e. '/articles') rather than having entirely separate route handlers for each [HTTP method]
									- i.e. app.get('/articles', ...), then app.post('/articles', ...), then app.put('/articles', ...)
								- Can "chain" them together via app.route, i.e.
									- app.route('/articles)
									-     .get(function(req, res) { ...
									-     .post(function(req, res) { ...
									-     .put(function(req, res) { ...
										- Note: Only put a ";" at the end of the last "chained" route, (i.e. after the .put)
						- Note: Can only have one response.send/.sendFile per route)
						- Route parameters
							- Let's you define one route to respond to multiple url strings using variables
								- app.[HTTP method]('/[fixed portion of url]/:[variable name for variable portion of url], function (req,res) { ...  
									- i.e. In [package.json "main" js file]
										- app.get('/users/:user_name', function (req, res) { ...
									- Which would respond to "[base url]/users/jane" in a browser window
									- Access [variable name for variable portion of url] via req.params.[variable name for variable portion of url]
										- i.e. req.params.user_name = "Jane"
									- Can respond to multiple fixed or variable portions of the url if desired
										- i.e. app.get('/users/:user_name/book/:book_id', ... )
									- [variable name for variable portion of url] can be made optional by adding "?" at the end
										- i.e. app.get('/users/:user_name?', function (req, res) { ...
											- Which will respond to either
												- "[base url]/users/jane" OR "[base url]/users"
										- Note: if a variable is optional, will need to add an if test for the variable being missing in the url string
											- This test must test for the type of the variable being undefined, rather than the value of the variable being null, (which are apparently different...)
												- i.e. if (typeof(req.params.user_name) === 'undefined') { ...
				- Client/server interation
					- Client, (displaying html file you sent -> [__dirname + "/[html file]"]), i.e:
						- <form action="/" method="post">
        					  	<input type="text" name="num1" placeholder="First Number">
        					  	<input type="text" name="num2" placeholder="Second Number">
        					  	<button type="submit" name="submit">Calculate</button>
    					  	  </form>
					- Server
						- Body Parser, (npm install body-parser)
							- In [package.json "main" js file]
								- "const body_parser = require("body-parser");"
								- (below the "const app = express();" line)
									- "app.use(body_parser.urlencoded({extended: true}));"
										- (several .[X] parser types)
								- Do whatever you want with the received data inside the app.post route, i.e:
								- app.post("/", function(req, res) {
									let num1 = Number(req.body.num1);
									let num2 = Number(req.body.num2);

									let result = num1 * num2;
									res.send("The result of the calculation is " + result);
								})
									- (Note: body-parser returns parsed items as strings by default)
						- Remote Elements, (via API)
							- (Using Node's https module)
							- https.get([url], function(response) {
								response.on([information desired from API response, often "data"], function(data) {
									JSON.parse(data);
								})
							})
								- (Note: "data" in above function arrives in hexadecimal format, hence use of [X].parse, where "data" is in [X, often "JSON"] format)
						- Templating
							- EJS, (Embedded JavaScript Templating)
								- Create "views" subdirectory in [project directory]
									- (precise directory name important - "views")
									- Make any html files in [project directory]/views with an ".ejs" extension, (instead of ".html")
										- To populate values from your [package.json "main" js file]
											- Add "<%= [variable name] %>"
										- To add control flow, (and only control flow) logic
											- (i.e. to change the way an element is rendered based on the result of [variable name])
											- Add "<%" and "%>" at the beginning and end of every single line of javascript only
												- (i.e. do not add to any lines with html tags), i.e.:
													- <% for(let i = 0; i < items.length; i++) { %>
            											<li><%= items[i] %></li>
        											  <% } %>
											- NOTE: When trying to comment out lines with <% %>
												- EJS will not respect regular html comment tags, (i.e. "<!--" "-->")
													- Meaning the line of javascript you just tried to comment out will still run
												- To actually stop lines with <% %> from running
													- You have to manually add javascript comment tags, (i.e. "//") AFTER the opening "<%"
								- In [package.json "main" js file]
									- To enable
										- "const ejs = require('ejs');"
										- (below the "const app = express();" line)
											- "app.set('view engine', 'ejs');"
									- To return information via a route
										- "res.render('[name of specific /views ejs file, without ejs extension - i.e. 'index'], {[variable name used in ejs file]: '[variable name used in [package.json "main" js file]]'});"
											- i.e. "res.render('index', {day: day});"
								- Layouts, (/Partials)
									- In Views directory
										- Create .ejs files to hold whatever commonly-repeated portions of pages you want
											- i.e. "header.ejs" and "footer.ejs"
										- Put repeated portions from [Main].ejs file into appropriate alternate .ejs files, i.e.:
											- In header.ejs
												- <!DOCTYPE html>
												  <html lang="en">
												  <head>
													  <meta charset="UTF-8">
													  <meta name="viewport" content="width=device-width, initial-scale=1.0">
													  <title>[Appropriate Title]</title>

													  <link rel="stylesheet" href="css/styles.css">
												  </head>
												  <body>
											- In footer.ejs
												- </body>
												  </html>
										- In [Main].ejs file
											- "<%- include('header') -%>" where header info used to be
											- "<%- include('footer') -%>" where footer info used to be
			- Modules, (local)
				- Way of externalizing bits of code for reuse / refactoring
				- Works same as any npm-installed module
					- (Other than requiring the absolute module filename, (local) vs module name, (npm))
					- In [package.json "main" js file]
						- Require module
							- const [constant name] = require(__dirname + "/[module filename relative to project directory]);
								- i.e. "const date = require(__dirname + "/date.js");"
						- Use functions in the module
							- [constant name].[function name WITHOUT parenthesis]();
								- i.e. "date.get_date();"
					- In [module filename relative to project directory]
						- Bundle desired functionality inside anonymous function(s) with appropriate return(s)
						- Connect anonymous function(s) with exports.[function name WITHOUT parenthesis]
							- i.e. "exports.get_date = function() {
								  	    [whatever get_date actually does, including return statement]
							  		};"
							- Gives [package.json "main" js file] access to function(s) return(s)
		
			- (Github)
				- Hiding API keys, (and other sensitive info)
					- Add ".env" file to [project directory]
					- Add ".env" line to .gitignore
						- (will keep any .env files from being committed)
					- Store any secret info in ".env"
						- In the form of one CAPITALIZED_KEYNAME='value' per line
					- npm install dotenv
					- In [package.json "main" js file]
						- "const dotenv = require('dotenv').config();"
						- Values of all .env key/value pairs available as "process.env.[CAPITALIZED_KEYNAME]"
				- Add 'node_modules' to .gitignore to avoid committing files generated by npm init.
					- To regenerate node_modules, including all dependencies, just type "npm install" with no arguments in [project directory]
						- Equivalent of "npm init" plus "npm install [modules]" for all [modules] in package.json / package-lock.json files in [project directory]
	- Deployment
		- Heroku
			- Prep for deployment
				- In [project directory]
					- Add file named "Procfile" to [project directory] that contains command to start app
						- i.e. "web: node index.js"
					- Mod app.listen to use process.env.PORT environment variable
						- (either adding "PORT=[desired local port number] to .env), or
						- ("app.listen((process.env.PORT || 3000),...))
							- (where [desired local port number] = 3000)
					- Add node version to package.json
						- "engines": {
							"node": "14.x" // (or whatever version of Node you're using)
						  }
				- Heroku Dashboard > "Settings" tab
					- Manually enter any needed environment variables, (from .env file) as "Config Vars"
			- Deploy
				- Through Github
					- Heroku Dashboard > "Deploy" tab
						- (Authorize Heroku to access your Github account)
						- Add repo name to "Connect to Github" section
						- Enable automatic deploys
							- Every commit to master will automatically push to Heroku
						- Or leave unchecked and manually deploy via "Deploy a Github branch"
							- Can also be used to deploy branches other than master.
				- Through command line
					- install heroku, (see heroku.com for details)
					- In [project directory]
						- "heroku create" to add heroku git remote
						- "git push heroku master"
	- Databases
		- SQL vs NoSQL
			- SQL, (/Relational)
				- Most popular: MySQL, (Postgres)
				- Stores records as entries in (multiple) tables linked by formal relationships
					- All entries have to have all attributes, (even if attribute = Null)
				- Pros
					- Very good in situations where a (relatively) larger number of entities generate few records
						- i.e. ecomm, (/Customers/Products/Orders)
					- Search speed for complex queries faster
			- NoSQL, (/Non-Relational)
				- Most popular: MongoDB, (Redis)
				- Stores records as JSON objects
					- Entries can have as many or as few attributes as relevant
						- Easier to make adjustments if requirements frequently change
					- Can still specify relationships between JSON objects via attributes, but not as efficient for complex queries
				- Pros
					- Very good in situations where a (relatively) smaller number of entities generate a lot of records
						- i.e. Blog posts / Twitter / Instagram
					- Cheaper to scale
						- i.e. Scales well horizontally
		- SQL
			- Table level
				- Create table
					- CREATE TABLE [table name] (
					  [column name 1 - i.e. "id"] [datatype 1 - i.e. "INT"] [column traits - i.e. "NOT NULL"],
					  [column name 2] [datatype 2],
					  ...
					  PRIMARY KEY ([primary key column name - i.e. "id"]) // optional
					  FOREIGN KEY ([local table column name]) REFERENCES [foreign table name]([foreign table column name]) // establishes relationships between tables.
					  )
				- Add columns to a table
					- ALTER TABLE [table name]
					  ADD [column name] [datatype];
				- Delete table
					- DROP TABLE [table name];
			- Record level, [CRUD]
				- [Crud] Create record(s) in table
					- INSERT INTO [table name] ([column name 1], [column name 2], ...)
					  VALUES ([value 1], [value 2], ...);
				- [cRud] Read record(s) from table
					- SELECT [column name 1], [column name 2], ... from [table name]
					  WHERE [column name(s)] = [value(s) that select only relevant records]
				- [crUd] Update value(s) in a table
					- UPDATE [table name]
					  SET [column name]=[value]
					  WHERE [column name(s)] = [value(s) that select only relevant records];
				- [cruD] Delete record(s) from table
					- DELETE FROM [table name]
					  WHERE [column name(s)] = [value(s) that select only relevant records]
			- Joins
				- Types
					- INNER JOIN = records exist in both tables
						- Left table record count = right table record count
						- Venn diagram = left table - union only, right table - union only
					- LEFT JOIN = all records from first, (i.e. left-most) table and values from second, (i.e. right-most) table where they exist
						- Left table record count >= right table record count
						- Venn diagram = full left table, right table - union only
					- RIGHT JOIN = (reverse of left)
						- Left table record count <= right table record count
						- Venn diagram = full right table, left table - union only
					- FULL OUTER JOIN = all records from left and right, connected where joined columns are equal
						- Left table record count + right table record count, including union
						- Venn diagram = full left table, full right table
				- SELECT [table name that contains foreign key definitions].[column name 1], [table name that doesn't contain foreign key definitions].[column name 3]
				  FROM [table name that contains foreign key definitions]
				  INNER JOIN [table name that doesn't contain foreign key definitions] ON [table name that contains foreign key definitions].[appropriate foreign key column name] = [table name that doesn't contain foreign key definitions].[column name in this table that matches foreign key in other table]
		- MongoDB
			- In Mongo Shell
				- Database level
					- Use, (/create) db => "use [database name]"
						- Confirm by showing current database => "db"
						- Note: if [database name] does not exist, it will automatically be created.
					- Delete db
						- use [database name that you want to delete]
						- db.dropDatabase()
				- Collection / Table level
					- Show all collections / tables => "show collections"
					- Relationships, (i.e. SQL Foreign Key "equivalent")
						- Preferred => Embed "sub-documents" directly into relevant records as an array, i.e.:
							- 	reviews: [
									{
										author: "Sally",
										rating: 5,
										review: "Best doodad ever!"
									},
									{
										author: "John",
										rating: 5,
										review: "Awesome doodad!"
									}
								]
						- Can also => Manually reference records in other collection(s) / table(s), i.e. in db.orders:
							- 	{
									order: 2541,
									products_id: [1, 2],  //  where [1, 2] = db.products.find({_id: 1}) & db.products.find({_id: 2})
									users_id: 245  //  where 245 = db.users.find({_id: 245})
								}
				- Record level, [CRUD]
					- [Crud] Create record(s)
						- db.[collection / table name].insertOne(   // or db.[collection / table name].insertMany( 
							{[JSON object(s)]}  // i.e. name: sue, age: 26, status: "pending"
							)
							- Note: if [collection / table name] does not exist, it will automatically be created.
							- Note: "_id" is the default primary key field.
					- [cRud] Read
						- db.[collection / table name].find(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause, optional
							{ [key_1]: 1, [key_2]: 1}  // 1 = true / yes, return this field, optional 
							).limit([max records to retrieve])  // limit, optional
						- db.[collection / table name].find()
							- Select * from [collection / table name] equivalent
					- [crUd] Update
						- db.[collection / table name].updateOne(  // or db.[collection / table name].updateMany(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause
							{ $set: { [key]: [value] } }
							)
					- [cruD] Delete
						- db.[collection / table name].deleteOne(  // or db.[collection / table name].deleteMany(
							{ [key]: [value / expression - i.e. { $gt: 18 }] },  // Where clause
							)
			- Mongoose
				- Connect to database
					- 	"const mongoose = require('mongoose');"
						"mongoose.connect('mongodb://[mongodb access url:port]/[database name]', [deprecation warning items, if any]);"
							- i.e. mongoose.connect('mongodb://localhost:27017/fruits_db', { useUnifiedTopology: true });
				- Create database schema to define the structure of all new records, (/documents) that will be added to the database.
					- Adding validation rules and relationships to other schemas, where desired
						- Note: Any relationships defined will really just embed foreign schema objects into the current record, akin to the "sub-documents" discussed in the "In Mongo Shell" section, above.
							- And, unless both aspects of the relationship, (i.e. the local object and the foreign schema object) are created and saved in the exact same run of index.js, (which will probably be extremely rare) though the data embedded will mostly be the same, the _id's of the object and its embedded counterpart will be different
								- So you won't be able to later query the _id of the embedded object and use that to query the table/collection that embedded object came from to get the original object
					- 	"const [schema name] = new mongoose.Schema ({
							[schema key_1]: {  // longer form, with validation
								type: [datatype],
								[validation_type_1]: [value],  // all validation_types are optional
								[validation_type_2]: [value],  // all validation_types are optional
							[schema key_2]: [datatype],  // shorter form, without validation
							...
							[local name for foreign schema object 1]: [foreign schema name]
						})"
							- i.e. const fruit_schema = new mongoose.Schema ({
								name: {  // validation
									type: String,
									required: true
								},  
								rating: {  // validation
									type: Number,
									min: 1,
									max: 10
								},
								review: String  // no validation,
								primary_pollenator: pollenator_schema
							});
				- Create model to define tables / collections
					- 	"const [capitalized model name] = mongoose.model([singular version of table/collection name - i.e. 'fruit' for a table/collection name of 'fruits'], [schema name]);"
							- i.e. const Fruit = mongoose.model('fruit', fruit_schema);
				- [Crud] Create actual record(s), (/document(s))
					- Create records to be saved to database
						- 	"const [record name] = new [capitalized model name] ({
								[schema key_1]: [value],
								[schema key_2]: [value],
								...
								[local name for foreign schema object 1]: [object created from foreign schema]
							});"
								- i.e. const apple = new Fruit ({
									name: "Apple",
									rating: 7,
									review: "A solid fruit",
									primary_pollenator: bee  // where bee was created via "const bee = new Pollenator ..."
								});
					- Save record(s) / document(s) to the database
						- Single item
							- "[record name].save();"
						- Multiple items
							- 	"[capitalized model name].insertMany([array of [record names] to be added], function(err) {
									if (err) {
										[error handling for failure to save records]
									} else {
										[success handling for saving records]
									}
								});"
									- i.e. Fruit.insertMany([kiwi, orange, banana], function(err) {
										if (err) {
											console.log(err);
										} else {
											console.log("Successfully added fruits");
										}
									});
				- [cRud] Read data from db to confirm all records saved
					- 	"[capitalized model name].find(function(err, [array name for [record names] to be retrieved]) {
							if (err) {
								[error handling for failure to retrieve records]
							} else {
								[success handling for retrieving records]
							}
						});"
							- i.e. Fruit.find(function(err, fruits) {
									if (err) {
										console.log(err);
									} else {
										console.log(fruits);
									}
							});
				- [crUd] Update record(s) in database, if necessary
					- 	"[capitalized model name].updateOne(   // or .updateMany(
							{[query parameters to locate record to be updated]},
							{[key_to_update_1]: [value_to_update_to_1], [key_to_update_2]: [value_to_update_to_2]},
							function(err) {
								if (err) {
									[error handling]
								} else {
									[success handling]
								}
						});"
							- i.e. Fruit.updateOne(
								{_id: 1},
								{name: peach},
								function(err) {
									if (err) {
										console.log(err);
									} else {
										console.log("Successfully updated record");
									}
							});
				- [cruD] Delete record(s)
					- 	"[capitalized model name].deleteOne(   // or .deleteMany(
							{[query parameters to locate record to be updated]},
							function(err) {
								if (err) {
									[error handling]
								} else {
									[success handling]
								}
						});"
							- i.e. Fruit.deleteOne(
								{_id: 1},
								function(err) {
									if (err) {
										console.log(err);
									} else {
										console.log("Successfully deleted record");
									}
							});
				- Close connection to database inside last interaction with database
					- 	"mongoose.connection.close();"
						- i.e. Fruit.deleteOne(
							{_id: 1},
							function(err) {
								if (err) {
									console.log(err);
								} else {
									console.log("Successfully deleted record");
									mongoose.connection.close();
								}
						});
						- Note: if done on its own, (i.e. not inside last interaction, as shown above) even if the command is at the very bottom of the index.js file, will throw one heck of a MongoError
			- Deployment
				- MongoDB Atlas, (cloud-hosted MongoDB service)
					- Add cluster, (free vs paid)
						- Select Cloud Provider, (AWS vs Google Cloud vs Azure)
						- Select Cluster Tier, (M0 = free)
						- Select version of MongoDB, (default fine)
						- Change Cluster Name, if desired
						- Click "Create cluster"
						- Set IP Whitelist to allow connection from wherever desired, (can be "from anywhere")
					- Add [mongodb user]
					- Connect to Cluster
						- From cluster webpage
							- Click "Connect"
								- Mongo Shell
									- Copy / paste connection string to terminal
								- Application
									- Copy / paste string to .env environment variable, changing:
										- "<password>" to [mongodb user's password]
										- "<database>" to [app's desired database name]
										- i.e. "mongodb+srv://[mongodb user]:[mongodb user's password]@[mongodb cluster url]/[app's desired database name]?retryWrites=true&w=majority 
									- Adjust mongoose.connect string to use new environment variable
										- i.e. "mongoose.connect(process.env.MONGODB_LOCATION_PRODUCTION, ...);"
									- Restart node server
	- API
		- RESTful
			- Client Request
				- Use HTTP request verbs
					- Get (cRud)
					- Post (Crud),
					- Put (crUd)
						- Updates / overwrites the entire record(s)
					- Patch (crUd)
						- Updates / overwrites only a portion of the record(s)
					- Delete (cruD)
				- Use specific pattern of routes / endpoint URLs
					- /articles => performs HTTP verb on all articles
					- /articles/george_washington => performs HTTP verb on individual "george_washington" article
				- Test via cURL, (or Postman, if you prefer GUI-based)
					- -X [HTTP verb other than GET, (GET is presumed)]
						- (Note: if you pass a -d / --data-binary, cURL presumes a POST, so -X flag not explicitly required)
					- -H "Content-Type: application/[x-www-form-urlencoded, json]"
					- -d / --data-binary '[raw data (-d) / filename of datafile (--data-binary) to pass]
						- x-www-form-urlencoded => '[key1]=[value1]&[key2]=[value2]&...'
							- i.e. 'id=5&title=my%20title'
						- json => '{"[key1]": "[value1], "[key2]": "[value2]"}'
							- i.e. '{"id": 5, "title": "my title"}'
						- datafile => @[filename]
							- i.e. @my_data_file.json
					- [URL to communicate with]
					- i.e. "curl -X POST -H "Content-Type: application/json" -d '{"id": 5, "title": "my title"}' http://localhost:3000/articles"
						- OR "curl -X POST -H "Content-Type: application/json" --data-binary @my_data_file.json http://localhost:3000/articles"
			- Server Response
				- /articles
					- GET => Show all articles
					- POST => Create one new article
					- PUT => N/A, (/undefined)
					- PATCH => N/A, (/undefined)
					- DELETE => Deletes all articles
				- /articles/george_washington
					- GET => Gets the article on george_washington
					- POST => N/A, (/undefined)
					- PUT => Updates the entire article on george_washington
					- PATCH => Updates a portion of the article on george_washington
					- DELETE => Deletes the article on george_washington
				- Add body-parser parsers to [package.json "main" js file] to correlate to HTTP Content-Types you wish to support
					- application/x-www-form-urlencoded
						- "app.use(body_parser.urlencoded({extended: true}));"
							- (also used to serve regular HTML)
					- application/json
						- "app.use(body_parser.json());"
					- Note: can have more than one parser enabled at a time.  
						- The Content-Type passed in the request header will determine which one should be used by that request.
	- Encryption & Authentication, (six levels of progressively stronger encryption)
		- (Level 1) Store plain-text info in database, (don't do this! ;) 
		- (Level 2) Using Encryption Keys
			- Using mongoose-encryption module
				- npm install mongoose-encryption
				- "const encrypt = require('mongoose-encryption');"
				- Generate encryption keys
					- Either:
						- Pair of base64 strings, (32-byte encryption key and 64-byte signing key), OR
							- Can be anything, but openssl very good for easily generating (pseudo-)random strings
							- In Terminal
								- "openssl rand -base64 32"
									- Save to .env file, (making sure to delete line breaks, if they exist)
										- i.e. ENCRYPTION_KEY = [random sigils in terminal as a result of the openssl ...32 command]
								- "openssl rand -base64 64"
									- Save to .env file, (making sure to delete line breaks, if they exist)
										- i.e. SIGNING_KEY = [random sigils in terminal as a result of the openssl ...64 command]
						- Single key of any length
							- Can be anything
				- Use encryption keys to encrypt mongoose.Schema, i.e.:
					-	"const user_schema = new mongoose.Schema({
							email: String,
							password: String
						});

						// Middleware for hashing
						const encryption_key = process.env.ENCRYPTION_KEY
						const signing_key = process.env.SIGNING_KEY

						// This adds _ct and _ac fields to the schema, as well as pre 'init' and pre 'save' middleware,
						// and encrypt, decrypt, sign, and authenticate instance methods
						user_schema.plugin(encrypt, {encryptionKey: encryption_key, signingKey: signing_key, encryptedFields: ['password']});"
					- Note: These lines need to be added before the new mongoose.model
					- Will automatically encrypt on every save command and automatically decrypt on every find command
						- Note: On find commands, only decrypts the return object(s), so:
							- Searching for a user(s) via unencrypted fields and then testing those results for decrypted fields will work, i.e.
								- 	"User.findOne({email: req.body.username}, function(err, found_user) {  // email is unencrypted
										if (found_user.password === req.body.password) { ..."  // password is encrypted
							- But using encrypted fields in the find command itself will not
								- 	"User.findOne({email: req.body.username, password: req.body.password}, function(err, found_user) { ..."  // email is unencrypted, password is encrypted
				- Vulnerabilities
					- If keys are obtained, all encrypted info can be immediately decrypted
		- (Level 3) Hashing
			- Mathematical function that can be very quickly applied to info that you want to protect to create a new, encoded, value
				- But takes much, much longer, (hopefully longer than would be worth the time to do) to reverse apply to the new, encoded, value to get back to the info that you wanted to protect
				- Will always yield the exact same new, encoded, value for each given input value
					- i.e. if given "123456," md5(123456) will always be the exact same string
			- Removes need for the weak link of an encryption key
				- That, once acquired, allows for full decryption of sensitive info
			- Using md5 module
				- "npm install md5"
				- "const md5 = require('md5');"
				- Save hashed password, (/other fields)
					- Simply apply md5 function to the password before saving
						- i.e. "password: md5(req.body.password) ..."
				- Find (/match) to hashed values in database
					- Simply apply md5 function to the unencrypted value and then compare that to the hashed value in the database
						- i.e. "if (md5(req.body.password) === found_user.password) { ..."
				- Don't need to worry about searching with unencrypted values first, then testing encrypted values as a second item, as above in the (Level 2) Encryption section
					- i.e. Both of the below will work, so just up to coding preference
						- 	"User.findOne({email: req.body.username}, function(err, found_user) {  // email is unencrypted
								if (found_user.password === md5(req.body.password)) { ..."  // password is encrypted
						- 	"User.findOne({email: req.body.username, password: md5(req.body.password)}, function(err, found_user) { ..."  // email is unencrypted, password is encrypted
			- Vulnerabilities
				- Subject to dictionary / brute force attacks
					- Since so many people use common (and simple) passwords
						- And hashing always returns the exact same encrypted string
							- Hackers can simply create a table that lists common words, passwords, addresses, etc, (i.e. a dictionary) and those passwords' hashed values
								- And can simply search any obtained hashed values against the hashed value column of that table to figure out original password
								- (Calculating md5 hashes for 20 billion potential passwords / dictionary entries to create such a table can be processed in ~1 second on modern GPUs)
		- (Level 4) Salting and Hashing
			- Salting = creating a random string for each password/value to be encrypted, which is then appended to it
				- With the concatenation then hashed
					- Since this new concatenation is a much longer / more unique password than what the user would have used
						- Much less vulnerable to dictionary attacks.
				- The "salt"/random string for each password/value to be encrypted is then stored in the database
					- Where it can be concatenated and hashed as needed
				- Makes any password significantly more unique, and thus much more difficult to perform a dictionary attack against.
					- But still potentially subject to dictionary attacks if hashes can continue to be calculated very quickly
						- i.e. md5 -> 20 billion/second
					- Could make dictionary attacks less likely:
						- If a much less efficient hashing algorithm was chosen
							- i.e. bcrypt -> 17000/second
						- If multiple "Salt Rounds" were performed, i.e.
							- Take [password], generate [salt], append [salt] to [password], hash [password+salt] to generate [hashed_string_1]
							- Take [hashed_string_1], append [salt], hash [hashed_string_1+salt] to generate [hashed_string_2]
							- Take [hashed_string_2], append [salt], hash [hashed_string_2+salt] to generate [hashed_string_3]
							- ....
			- Using bcrypt module
				- Note: bcrypt is only released for stable versions of Nodejs
					- Should be even-numbered releases
						- As of 2020-09-15, though, the Current version is 14.10.1, which should be stable
							- But there is no version of bcrypt listed on their website for version 14
								- So reverted to the LTS version, (12.18.3) via the npm n module
									- In Terminal: "sudo n lts"
				- "npm install bcrypt"
				- "const bcrypt = require('bcrypt');"
				- "const salt_rounds = [number of salt rounds to use - 10 is a solid first choice];"
					- i.e. "const salt_rounds = 10;"
				- To store salted and hashed password, (/other field) in MongoDB
					-	".post(function(req, res) {
        					bcrypt.hash(req.body.password, salt_rounds, function(err, hash) {
								const new_user = new User({
									email: req.body.username,
									password: hash
								});
								new_user.save(function(err) {
							..."
				- To compare entered password to salted and hashed password, (/other field) in MongoDB
					-    ".post(function(req, res) {
        					User.findOne({email: req.body.username}, function(err, found_user) {  
            					if (found_user != null) {
                					bcrypt.compare(req.body.password, found_user.password, function(err, result) {
									if (result === true) {
										// TO DO when passwords match
                    				} else {
										// TO DO when passwords DON'T match 
									}
							..."
					- Note: we're back to testing email first, password as second call.
				- Note: the bcrypt module combines the salt with the hash and stores both values as the hash/password, (/other field) in the database
					- From which it automatically parses the two parts as / when necessary.
		- (Level 5) Cookies and Sessions
			- Using passport module, (passportjs.org)
				- "npm install passport passport-local passport-local-mongoose express-session"
					- (Note: 'express-session' NOT 'express-sessions')
						- (Possible aid in making sure you're using the right package: check weekly downloads on Github) 
				- 	"const session = require('express-session');"
					"const passport = require('passport');"
					"const passport_local_mongoose = require('passport-local-mongoose');"
						- (Note: 'passport-local' is a dependency of 'passport-local-mongoose,' but is never called directly in the code, so doesn't need to be explicitly required)
				- (At end of app.use section)
					- 	"app.use(session({
    						secret: process.env.SESSION_SECRET,
    						resave: false,
    						saveUninitialized: false
						}));"
							- (Where SESSION_SECRET in the .env file is any string)
								- (Can generate via "openssl rand -base64 32" / "openssl rand -base64 64")
						"app.use(passport.initialize());"
						"app.use(passport.session());"
				- (After "const [Mongoose Schema Name] = new mongoose.Schema({ ..." )  // Creating the schema
					- 	"[Mongoose Schema Name].plugin(passport_local_mongoose);"
						- i.e. "user_schema.plugin(passport_local_mongoose);"
				- (After "const [Mongoose Model Name] = new mongoose.model('[Mongoose Model Name]', [Mongoose Schema Name]);")  // Creating the model, using the above schema
					-	i.e. "const User = new mongoose.model('User', user_schema);"
					-	"passport.use([Mongoose Model Name].createStrategy());"
						- i.e. 	"passport.use(User.createStrategy());"
					-	"passport.serializeUser(function(user, done) {
							done(null, user.id);
						});"
					- 	"passport.deserializeUser(function(id, done) {
							User.findById(id, function(err, user) {
								done(err, user);
							});
						});"
				- To register new user
					-	".post(function(req, res) {
        					User.register({username: req.body.username}, req.body.password, function(err, user) {
								if (err) {
									console.log(err);
									res.redirect('/register');  // Or wherever the register route is
								} else {
									passport.authenticate('local')(req, res, function() {
										res.redirect('/[Whatever route is for your authenticated users only]');
											// i.e. "res.redirect('/secrets');"
									})
								}
							});
						});"
				- To login pre-registered user
				    -	".post(function(req, res) {
							const login_user = new User({
								username: req.body.username,
								password: req.body.password
							});
							req.login(login_user, function(err) {
								if (err) {
									console.log(err);
									res.redirect('/login');  // Or wherever the login route is
								} else {
									passport.authenticate('local')(req, res, function() {
										res.redirect('/[Whatever route is for your authenticated users only]');
											// i.e. res.redirect('/secrets');
									});
								}
							});
						});"
				- To test whether a user is authenticated before displaying [Whatever route is for your authenticated users only]
					- 	"app.route('/[Whatever route is for your authenticated users only]')
							// i.e. "app.route('/secrets')"
    						.get(function(req, res) {
								if(req.isAuthenticated()) {
									res.render('secrets', {
										user_email: req.user.username
									});
								} else {
									res.redirect('/login');
								}
							});
				- To log user out
					- 	"app.get('/logout', function(req, res) {
							req.logout();
							res.redirect('/');
						});"
		- (Level 6) Third Party Oauth 2.0 / Social Signins
			- Why Oauth?
				- Developer can ask User for access to only very specific bits of information
				- Developer can ask User for Read-only or Read/Write access
				- User can revoke any permissions granted to anyone from authorizing website
					- i.e. Google, Facebook, Twitter, etc
			- How to Enable
				- Step 1 - (one-time/website) Set up your application on website with which you will be using Oauth, (Google, Twitter, et al)
				- Step 2 - Redirect User to website of trusted party to authenticate
				- Step 3 - User logs in on trusted party's website
				- Step 4 - (one-time/website) User reviews / grants permissions you're requesting
				- Step 5 - Receive Authorization Code, (AuthCode) from third party website, confirming User
				- Step 6 - (one-time/website) Exchange AuthCode for Access Token
					- Store in db to access user's third-party account to retrieve any User-granted info without User
			- Using passport module
				- (See Level 5 for initial passport installation and configuration)
				- Pick Passport "Strategy" for website you want to authorize with from passportjs.org
					- Install Passport strategy module shown for the desired website, (i.e. passport-google-oauth)
						- i.e. "npm install passport-google-oauth20"
					- And mongoose-findorcreate module to make registering or logging in a single command, (akin to upsert)
						- (Passport strategy docs show a .findOrCreate pseudocode method that doesn't actually exist to just tell you you have to implement this functionality.  Luckily, someone simply turned the pseudocode call into an actual module so that you don't ;)  )
						- i.e. "npm install mongoose-findorcreate"
						- "const findOrCreate = require('mongoose-findorcreate');"
							- (Note: this module seems to insist on the const explicitly being named "findOrCreate".  Any other name, i.e. "find_or_create", comes back with an "is not a function" error.)
						- (After "const [Mongoose Schema Name] = new mongoose.Schema({ ..." )  // Creating the schema
							- 	"[Mongoose Schema Name].plugin(findOrCreate);"
								- i.e. "user_schema.plugin(findOrCreate);"
					- Setup Oauth access on developer section of third party authorization website
						- i.e. https://console.developers.google.com/
							- Create new project
							- Go to Credentials
							- "Configure Consent Screen"
								- "External" -> Create
								- Fill in page, (i.e. Application name, logo, support email, etc)
								- If you want more than the default email/profile/openid, click "Add Scope" and do whatever's needed to add additionally-requested info
							- Go back to Credentials
								- "Create Credentials" > OAuth client ID
									- Fill in info, especially:
										- "Authorized JavaScript origins," (the page that will be making the request to Google)
										- "Authorized redirect URIs," (the page you want Google to send the user to after authenticating)
									- Will give you "Client ID" and "Client Secret" codes
										- Add to .env file
					- Configure Strategy
						- "const Google_Strategy = require('passport-google-oauth20').Strategy;"
						- (After "passport.deserializeUser([Mongoose Model Name].deserializeUser());")
							- 	"passport.use(new Google_Strategy({
										clientID: process.env.GOOGLE_CLIENT_ID,
										clientSecret: process.env.GOOGLE_CLIENT_SECRET,
										callbackURL: process.env.BASE_URL_DEV + process.env.PORT + '/auth/google/secrets'   // Swap to BASE_URL_PROD when releasing
									}, 
									function(accessToken, refreshToken, profile, cb) {
										User.findOrCreate({ googleId: profile.id }, function (err, user) {
											return cb(err, user);
										});
									}
								));"
					- Authenticate Requests
						- 	"app.get('/auth/google',
								passport.authenticate('google', { scope: ['profile'] })
							);
						-   "app.get([Google Authorized redirect URIs],
						 		// i.e. "app.get('/auth/google/secrets',   
								passport.authenticate('google', { failureRedirect: '/login' }),
								function(req, res) {
									res.redirect('/[Whatever route is for your authenticated users only]');
										// i.e. res.redirect('/secrets');
								}
							);
					- Store Google ID to database to function as an alternate user id for all data created on our site
						- Since the third-party Oauth'd user won't have a local email address to store and use in the future
							- And apparently Google doesn't send in their profile.
						- Add "googleId: String" to schema